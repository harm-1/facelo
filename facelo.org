#+STARTUP: indent
#+STARTUP: overview

* Aanpak
** frontend
*** 1
Eerst ging ik de app maken, maar ik denk nu dat dat geen goed idee is. 
Ik denk dat het makkelijker is om een website te maken. 
En dan natuurlijk eerst de frontend. 

Ik heb toruwens alle android data direct in de facelo folder gedaan, kan ik dat gewoon verplaatsen?
Ik denk het wel. Kon niet maar nu is het gefixed
*** 2
Ik wou beginnen met het maken van de frontend maar wist echt niet goed waar ik moest beginnen.
Het lijkt erop dat ik nog steeds alles in html moet zetten. Best wel leip. 
Ik moet dus in html de website maken, dan in css stylen. Dan in vue data vanuit de server in de html zetten. 

----

Ik ging ff een filmpje kijken en over en ben blij dat ik hierboven fout zat. Ik realiseer me nu wel hoe weinig ik eigenlijk weet van web programming. Bij een vue file zit de html css en script in dezelfde file.

Ik ben nu begonnen en herrinner me weer van die views en components. Maar het allemaal nog echt tering vaag. 
Ik geloof dat ik een view moet maken en dan daar allemaal components in stoppen. 
Ah ja je hebt ook een router. 

Wat ik alleen niet snap is wat er nou als eerste wordt gecalled. Ik kijk nu bij een example project. Het ziet er allemaal uit als toen bij het project maar ik snap het nog steeds niet. 
Het is dit project: https://github.com/gothinkster/vue-realworld-example-app

Ik heb nu gevonden dat de 'index' dit file is: App.vue
Maar in index wordt een router view gespecificeerd en er wordt verder nergens naar gelinked. 

Ik heb gevonden dat er een tool is voor het opzetten van een simpel vue project. Ik denk dat het beste is om te doen
Okee gedaan en het eerste wat ik zie vind ik niet leuk. Ik zie dat er localhost in de bar staat. Dit betekent geloof ik dat er een webserver is geinstalleerd en dat er automatisch naar dt project wordt verwezen. 
Ohnee, het betekent gewoon dat de applicatie runt op een bepaalde port. 

Het is een dasboard. 
Ik zat f verder te kijken hier: https://www.freecodecamp.org/news/a-quick-introduction-to-vue-js-72937ee8880d/
Het lijkt erop dat als ik zelf wat maak, dan zie ik alleen me eigen shit.

Het dashboard is een website voor het managen van vue en doet verder niks met mijn project. 
Met npm run serve in de project folder start de server en kan ik mn eigen website zien.
*** 3
Nu dat ik een basic setup heb, moet ik maar eens wat frontend gaan maken. Ik begin met het voorbeeld

Ik ga eerst ff de aanpak updaten. 
Ik kan het project denk ik opdelen in: frontend backend en android. 

Ik ga eerst alle components views en router creeren en dan pas invullen.

Ik merk tijdens het bestuderen van vue, dat mijn webdev kennis een beetje gebrekkig is. 
Ik ben vooral wezen lezen van documentatie. Maar de documentatie begon bij details in plaats van overviews. 
Ik wil nog steeds eerst die router shit gaan bouwen, maar het lijkt erop dat dat op verschillende manieren kan. 
Daardoor ben ik zoveel documentatie aan het lezen. Het verwarrende is ook dat er een aparte site is voor de router documentatie. Ik daar nu aan beginnen. 

De router is blijkbaar ook package op zichzelf. Er zijn ook allemaal verschillende manier om het te installeren. 
Ik ga denk ik gewoon vue add router doen. Het overschrijft de app.vue, maar dat is oke. 

gedaan, nu wil ik de eerste testcomponent toevoegen.

Ik zit eerst even te kijken naar hoe alles werkt, en er niet heel veel van eigenlijk. In het main.js file snap ik niet wat render doet. 

Ik probeerde net in de main.js file om de app the verwijderen, gewoon om te kijken wat er dan niet meer werkt. Maar de vue instance in main.js heeft zowel de app als de router nodig. De App gebruikt namelijk de router. Zonder de app compiled hij prima, maar je ziet niks omdat de router alleen data heeft die in de app moet. De router is zeg maar model en de app is viewmodel. denk ik.

<router-view/> is blijkbaar de normale view.
Na lang een of andere rare error te hebben gehad, heb ik een significante stap gemaakt. Ik heb de first view toegevoegd aan de router.   
*** 4 
Okee, wat is de volgende stap? Ik heb ondertussen veel van spacemacs geleerd en het bevalt me steeds meer. 
Ik denk dat ik gewoon de frontend mooit moet gaan maken. 

Ik begin denk ik met de user overview page. 
*** Results page
Dit is moeilijker dan ik had gedacht. Ik denk dat ik gewoon met html moet beginnen. 
Waarschijnlijk moet ik een html tutorial doen.

Ik moet of een html tuto doen of een vue tuto. Of beide. Ik ga denk ik snel doot de html en vue tuto heen en dan weet ik het wel denk ik. 
- Done html tuto 
- TODO Vue tuto

Ik kijk naar een example project en ze gebruiken bijna alleen maar normale html elementen. 
Het enige van vue is routen-link en routerview. 

Ja het is pretty much allemaal html. Ik heb eigenlijk helemaal geen zin om dat allemaal te doen. 
Ik ga het wel doen. 

Ik denk dat het misschien toch beter is om gelijk met de backend te beginnen. 
Anders moet sampledata gaan maken en speciaal code gaan ontwikkelen om het in de database te zetten. 
*** Backend
Okee, waar begin ik. Ik denk dat ik de database moet opzetten. 

Ik ben maar de documentatie van flask aan het lezen en er is veel te veel dat ik niet begrijp. 
Ik zit dus o.a. te kijken naar de dependencies van flask en zag jinja dat blijkbaar page rendering doet. Ik snap niet waarom dat in flask zit want page rendering gebeurt client side. 

Ik denk nu dat is voor als je simpele websites maakt. Dan wordt het serverside gewoon gerenderd en dan wordt de kant en klare html naar de client gestuurd.

Maar waar wordt de router van vue dan voor gebruikt. 
Ah het is voor single-page application. Ik denk dat ik dat wil. De html is toch bijna niks en de images kan je laden wanneer het gevraagd wordt.  

Dit doet me realiseren dat ik voor mn website eigenlijk zowieso placeholder images moet hebben. En waarschijnlijk wel beter met de frontend kan beginnen. 
*** Placeholder images
Okee, ik ga weer naar de frontend en ga een placeholder image gebruiken voor pretty much alles. 
Ik moet kijken waar ik die opsla eerst. 
Ik denk dat ik gewoon een resources folde ga maken. 
okee, dit is wel nice: http://placehold.jp/en.html
*** Frontend
Okee, ik ben nu weer met frontend bezig en kan niet een comment zetten onder mn  hoofd div. 

Het probleem was gewoon dit: 
    <html lang="en"/>
Er mag maar 1 element in de root zitten dus dit zou in een div moeten. IK heb het gewoon weg gehaald. 

k kan natuurlijk gewoon een div om alles doen. Maar laat het nu zo. 

Okee, nu de eerst page mooi maken. Dit is waarschijnlijk redelijk wat werk maar ik denk dat het vandaag moet kunnen. Ik moet html met v-if en v-for gebruiken. En wat js logica. 
Mischien ook een component eigenlijk. 

Ik ga beginnen met een js setup en kijken of een var kan gebruiken. 
Misschien eerst ff een js tuto. 
Misschien is het niet nodig maar ik denk dat dit een prima begin is.

js tuto gedaan. Nu de eerste pagina. 

Wtf dit is echt tering veel werk. 
Ik zag bij realworld voorbeeld dat er export om alle code zat. 
Ik neem aan dat dat is zodat het door andere code gebruikt kan worden.

Okee, ik kon geen shit uit mn script in de template krijgen, nu wel.
Ik moet eigenlijkde de documentatie van vue gaan lezen, maar ben bang dat ik het toch niet gan begrijpen. 

Om een of andere vage reden moet data een functie zijn. Als het geen functie zou zijn dan zouden components dezelfde data hebben blijkbaar. Ik vind niet alles logisch hier. 

Er zijn zoveel verschillende manieren om components te maken en regsitreren dat ik duizelig wordt. 
In de officele documentatie zie ik bijne niet de manier die gebruik terwijl is een standaard project setup van hun heb gebruikt. 
Ik zie nu dat ik een moduls system heb. 

Ik denk dat ik webpack uit moet pluizen.
Ik heb een video gekeken, dat was wel handig. 
vroeger moesten mensen js met scripts(<src>) invoegen wat error gevoelig was. 
Maar vue gebruikt imports dus ik denk dat het bij vue niet perse nodig is. 
Wat ik ook niet gerealiseerd is dat als je bij een webpagina een image wilt laten zien, dan moet je een url gebruiken. Je kan niet het path gebruiken. webpack laat je wel een path gebruiken en zet het automatisch om in een url. 
Verder maakt het ook een depency graph. Als je script A, B en C hebt en A depends on B en C. En B alleen op C. Dan moet moet je bij het laden van A eerst C laden en dan pas B. In normale programmeertalen kan je B gewoon C laten laden, maar bij webprgrammeren worden de scripts via html geladen en ik denk dat dat dan niet via js kan. Iig externe scripts kunnen dat niet. 


Ik realiseer me net dat vue de data van een component en dan waarschijnlijk de naam van de variablen onder de kap veranderd. Ik denk dat alleen op die manier de variabelnamen per component uniek kunnen zijn. Daarom moet het denk ik een functie zijn. 
*** Component
Okee, ik heb eerst wat aan mn result view gewerkt en wil nu dus een reusable component erin gebruiken. 

Ik moet beslissen of ik de require context functionaliteit ga gebruiken. 
Ik denk dat ik dat voorlopig niet doe

Okee, Ik heb de eerst component in mn eerste view gezet. 
Dit is echt een stuk meer werk dan gehoopt. 

*** Login page
Ik denk dat dit wel een goede stap is. 

Het hele authenticatie ding is lastig denk, maar ik denk ook een enorme stap. 
Ik kan jasonplaceholer gebruiken voor dummy data. 

https://www.youtube.com/playlist?list=PLpzy7FIRqpGDuLIo0zZ43CpA5MmYnnCUy

Ik denk eigenlijk dat ik gewoon gelijk een database wil maken. 
Ik begin nu met het maken van de login frontend, en dan de bd en backend. 

https://www.youtube.com/playlist?list=PLpzy7FIRqpGDuLIo0zZ43CpA5MmYnnCUy

Ik ben nu een beetje aan het googlen naar login page omdat ik bang ben dat ik het verkeerd aanpak. 
Maar misschien moet ik niet zo bang zijn. 

Ik denk dat ik die axios shit gewoon moet gebruiken van die tuto. Dan weet iig dat dat werkt. 
Dan voor de login page gewoon een heel simpel design maken en dan de ajax calls opzetten. 
Ik kan dat dat testen in de browser. daarna de backend. 
html is in pricipe ook gewoon heel simpel. Het is ook het beste om het zo simpel mogelijk te houden. 
css is alleen wat gekut. 

Ik heb me wat in vuex verdiept en ik denk dat ik dat moet gaan gebruiken. 

-----------

Ik heb vuex, axios en een simpele html login page nodig en ik haal alles nu door elkaar. 
Ik weet ook niet wat het beste is om mee te beginnen. 
Ik denk vuex het laats. 
Ik doe wel gewoon eerst de html. 

Okee, html denk ik done. 
Nu axios denk ik. Ja, axios, dan db en api, dan pas vuex. 
*** axios
npm install axios
import en niet require.
** backend setup
*** Backend login
Okee, ik moet een database opzetten en de backend. 
Ik ga flask gebruiken omdat ik een video heb bekeken van de meest populaire frameworks: 
https://www.youtube.com/watch?v=9z_2wmJOom4
En de nummer 1 in php dus die valt af. De nummer 2 en 3 zijn flask en django, en flask is makkelijk om te leren heb ik gelezen. 

Ik moet dus een flask project opzetten. 
Maar hoe komt het dat ik nu mn app kan laden. Er moet al iets van een backend zijn denk ik. 
Ik ben zo in de war nu. 

Okee, de vue shit runt op port 8080 nu. En de flask program gaat op 5000 runnen. 
Dus de vue kan gewoon door mn huidige webserver(welke dit dan ook is) worden verstuurd. En de vue kan dan calls doen naar mijn backend. 

Okee, ik denk dat ik het weer snap. Er is een webserver die de connecties onderhoudt. En die verstuurd de frontend naar de clients. Je kan die functionaliteit natuurlijk niet in de frontend zitten. Dan zou functionaliteit moeten hebben die meerdere connecties onderhoudt. 

Ik realiseer nu dat er verschillend manieren zijn om de website te maken.
https://testdriven.io/blog/combine-flask-vue/
Ik kies voor de single page application. Ik wil een goede snelle UI, ik denk dat dat erg belangrijk is.
Ik wil ook de frontend en backend volledig scheiden. Ik vond dat chil en overzichtelijk. 

Ik ga dus flask met cors gebruiken. 
Ik denk dat de volgende stap voor nu is om gewoon een basic flask app te maken en simpele data te versturen naar de vue shit. 
*** flask setup
Dus het eerste probleem hiermee is dat spacemacs de project folder als facelo_website detecteerd.

Ik zat dus op te zoeken hoe ik dat verander en toen vroeg ik me af hoe zo een project normaal wordt gestructureerd is. 

Wat ik eigenlijk wil is om de frontend en backend helemaal gescheiden te houden, maar ik denk dat dit alleen maar moeilijk gaat zijn. 

Okee, ik ga het toch opsplitsen. Ik moet dus eest de projectile root veranderen.
Ik denk dat als je twee folders in elkeer hebt die als projectile folder gedetecteerd kunnen. Dat root automatisch het project wordt. Dus ik hoef denk ik alleen een makefile te maken.

makefile en restarten 
Okee dat werkt. Maar nu zit alle android shit ertussen. Ik wil android wel in deze folder houden. Maar niet bij mn projectile files zien. Dus ik moet een .projectile file maken. 
*** projectile
Ik kon het niet fixen omdat het .projectile file niet werkt. Maar blijkbaar kijkt projectile naar gitignore. 
Dus gelukkig weet ik dat nu. 

Maar nu kan ik ook niet de inhoud van de frontend folder zien. Waarschijnlijk kon ik dat eerder ook al niet, maar had ik het nog niet door.
Ik denk dat het komt doordat de frontend een project opzich is. 

Okee, uiteindelijk gelukt. projectie ignores .projectile files als er een gitignore of git folder is. 
Als een subdirectory een git folder heeft dat worden alle files in die folder niet tot dit project beschouwd. 

Dus ik moet in de gitignore de android shit ignoren en in de frontend folder de git folder verwijderen. 
Ik vind het echt best wel knap en super chil dat ik dit heb uigevogeld. 
*** flask setup
Ik moet eerst de environment opzetten. 
Er was geen activate file maar opnieuw hetzelfde command runnen loste het op. 

Om het te activeren moet ik . venv/bin/activate gebruiken. 
Wat th fack doet die punt daar. 

https://unix.stackexchange.com/questions/114300/whats-the-meaning-of-a-dot-before-a-command-in-shell
Blijkbaar zijn er twee manieren om scripts te runnen. 
./command gebruikt een apart process. 
. ./command gebruikt hetzelfde process. 
source is hetzelfde als .

Ik denk dat de volgende stap is om een flask tutorial te doen. 
Ik doe eerst een yt tuto, en daarna de officiele. Het is veel werk maar ik denk dat dit een goed idee is. 

Deze tuto is echt tering goed:
https://www.youtube.com/playlist?list=PL-osiE80TeTs4UjLw5MM6OjgkjFeUxCYH

Ik doe nu dus een tutorial en dan nog een en dan pas het werk. Maar misschien is het beter om gelijk te
beginnen. Ik wil bijvoorbeeld zowieso sqlalchemy gebruiken. En ik moet ook een user table maken. 
Nee ik ga gewoon zn code kopieren. En dan moet ik weten wanneer ik andere code wil schrijven. Ik ga door to hij shit doet die niet relevant voor mij is. 

Nee ik ga zowieso dingen opnieuw bekijken want het gaat snel en is moeilijk. Het was een goed idee om door te kijken naar de structuur, maar nu veranderd de structuur niet meer dus ik kan wel al dingen gaan doen. Ik denk dat het het beste is om code vanaf de structuur episode te kopieren en dan naar mijn site maken.

Ik heb nu code van de officiele tuto genomen maar ik vind een andere leerzamer. Dus ik denk dat het het beste is als ik nu alleen code van die andere gebruik. en dan later ga vergelijken. 

Ik kan gewoon niet wennen aan die rare imports. Het is gewoon niet logisch. Misschie moet ik maar die officiele tuto gebruiken. De officiele tuto gebruikt denk ik die factory zodat ze die rare imports niet hoeven te doen. Ja ik ga de officiele tuto aanpak gebruiken en dan de code van die andere erbij doen. 

Ik denk dat circular imports onvermijdelijk zijn met flask. Maar het maakt niet uit als je alleen import zoals er wordt gedaan en gezegt in de tuto. 
Ik denk toch dat ik de app factory ga gebruiken ipv van de andere tuto. 
Die circular zijn onvoorkombaar omdat je in je init je views/routes moet importen. 
En je wilt in je init je app initialiseren. 
Dus je import flask, initialiseert app, en importeerd routs, views. 

routes zijn aanpassingen op de app instance. Ze voegen wat toe. Het zijn geen functies of classe. Daarom moet je de app importen. Het hele probleem is eigenlijk dat je routes je app moeten importeren. 
Waarschijnlijk moeten je routes je app importeren omdat ze bia je app bij je db komen. 
Het is wel grappig dat ik hier nu tegen aan loop want ik had soortgelijke problemen met mn scriptie. 

Je hebt application en request contexts in flask. Ik denk dat het best wel belangrijke onderwerpen zijn en ik snap ze niet echt eigenlijk. Maar ik denk dat het beter is om er later naar te kijken omdat ik dan een beter beeld van flask heb. 

Ik ga dit bekijken. https://www.youtube.com/watch?v=fft6IvL-y1g&list=PLCuWRxjbgFnOgjL5rynXlnotsDhsi00Xa&index=3
Hij begint al zn applicaties heel klein en maakt er meer files van wanneer dat nodug is. Ik heb steeds meer het idee dat dit de beste manier van werken is. 
Ik snap nu beter hoe de context werkt.
*** Backend login
Ik heb de flask setup zoals ik wil. 
Nu dus eindelijk de login functionaliteit. 
Ik heb weer geen idee wat ik moet doen
Moet ik niet eigenlijk eerst frontend hiervoor doen

Coreys aanpak is eigenlijk heel erg verschillend dan die van mij. 
Hij gebruikt modules voor de forms die ik niet kan gebruiken. 
Ik moet de data via een standaard versturen en uitlezen en dan kijken of dat passwoord mag en dan responden. 
Ik moet een cors voorbeeld hiervoor vinden. Er is geen tuto. 

Er is een realworld app en het lijkt erop dat bij een route de argumenten van de functie key van de data van een http request zijn. Ik moet die documentatie even lezen. 
https://flask.palletsprojects.com/en/1.1.x/api/#url-route-registrations
realworld ding gebruikt alleen argumenten in de functie. 

Holy fuck dit zo fucking moeilijk. 
Ik denk dat ik eerst de frontend van de login moet gaan doen.
** api
*** Frontend login
Fack dit is zo moeilijk. Ik zie nu van de realworld vue app hoe ze die request maken. 
En snap het meeste. En ik ga dat ook zo doen. Maar ik snap niet hoe ik het kan checken. 
Ik denk dat ik het gewoon kan zien als ik logging van flask aan heb. 

Okee, ik wil nu een tuto van vue login vinden.
Alles gebruikt een store voor het inloggen. 
Dat is ook logisch want je moet overal kunnen weten of iemand ingelogd is. 
Ik dus eerst de store maken.

Ik zat net te denken waarom nu eigenlijk de frontend weer doe in plaats van de backend. Ik ging namelijk backend doen omdat de frontend dat nodig had. Dacht ik. Ik realiseerde toen in de backend routes voor login ging doen dat dat een post request was. En daarvoor kan in beter met de frontend beginnen.
Dus nog steeds eerst store. 
*** vuex store
Ik snap niet wat use doet. Het voegt een plugin toe aan vue ofzo. 
Maar het voegt niet werkelijk een plugin toe aan het framework, maar meer aan mijn app. 
Mijn app is een instance van het framework. 

Ik denk dat de plugin aan het framework moet worden toegevoegd en vervolgens ook oet worden geimporteerd in de app instance. Ik weet niet zeker of ik dit logisch vindt. 

Okee, ik had wat problemen, ik kon niet bij de count var en ik denk dat het is opgelost doordat ik een getter heb gemaakt.

Okee, nu ik dit heb, waar ik belachelijk lang over heb gedaan, wat heb ik eraan. Ik vind het zo lastig om te weten hoe ik het aan moet pakken. Ik denk dat ik maar een rest call ga maken. 
*** axios 2.0
Hmm, ik denk in de login view. 

Ik wil een apiservice maken zoals in de realworld voorbeeld, maar ik snap niet wat de jwt service is en doet. Er wordt een token gebruikt voor de authorisatie. Het is redelijk logisch. Bij authorisatie wordt een token opgeslagen en dat dat token wordt aan de header toegevoegt bij communicatie. 

Ze doen alle api calls in de store om een of andere reden. Is dat logisch?
Eigenlijk doen ze het toch in de apiservice, maar veel dingen die ze ophalen uit de backend moeten ze in de store opslaan. 

Okee, ik ga het hetzelfde doen. Want ik het erg netjes en overzichtelijk gedaan. 
Behalve die type bullshit. 
**** check_auth
Ik snap niet wat dit doet. 
Ik denk dat bij je bij login een token krijgt, en bij loguit wordt deze verwijderd. 
Waarom zou je ooit willen weten of er een token is. 

Stel dat je de token verwijderd als user met remove cache ofzo, dan heb je ineens geen token meer als je die wel zou moeten hebben. Maar wat maakt dat uit? 

Je wilt zowieso altijd serverside de authentie controleren, dus het is zowieso niet dat je data kan lekken. De clientside checkauth is altijd voor de user experience. je wilt niet de ingelogde pagina's zien als je niet ingelogd bent. Ik denk dat het idd gewoon voor UX is. 
**** context
Okee wat doet dat. Het is een var in de auth store. vuex actions krijgen een context altijd. 

Ah ze gebruiken argument destructuring. Dat is vrij verwarrend als je geen js kent. 
Wtf is dat haha. 
Bij: increment (context); is het een functie met het context argument.
Bij: increment ({ commit }); is het een functie waarvan het argument een class is met een property die commit heet. 
*** Api & store
Deze twee ga ik dus tegelijk maken. Ik wil de api maken, maar de data komt in de store dus in de store maak ik functionaliteit die de api aanroept. 

Ik zat hier ff vast mee omdat ik niet weet of ik code wil kopieren van realworld. Oke, het mag iig want het is een mit license. Dus ik kan dat gewoon doen en ga dat dus ook doen. 

Okee, ik heb token code gemaakt, de config voor de url, de store herschreven zodat ik modules kan gebruiken. Nu wil ik de api service maken, maar ik snap niet wat de store daar doet. 
In de init wordt vue.use(axios, Vueaxios) gedaan. Waarom twee keer axios en waarom hier?

Ik denk dat ze dat er voor de zekerheid doen in het geval dat de apiservice eerder dan de store wordt aangeroepen. Het is denk ik goede practice om dit daar te zetten want dan zie je gelijk welke plugins er benodigd zijn ddoor deze file. Het maakt niet uit hoevaak je vue.use schrijft voor een plugin, het wordt altijd 1 keer geimporteerd. Ah  trouwens, ik haal vuex en axios door elkaar. 

Er zit een init functie in de apiservice, die wordt handmatig gecalled. 

Ik snap niet waar vue axios voor wordt gebruikt, ik ga die gwoon verwijderen als ik iets werkends heb. 
Aha, in de axios documantie staat je ze beide moet gebruiken. Ah, axios is niet vue only. Duh

Ik wil waarschijnlijk axios auth gebruiken. 

De slug is gewoon het einde van de url. 

De api service gebruikt gewoon get, post, put en delete. en voegt toe query en update. 
Ik weet niet of ik dat gebruiken, maar ik hou het gewoon. 
*** Login store module
Ik kopieer gewoon de store van realworld alleen ik hoef die type shit niet. 
Ik heb het weg gehaald, maar nu heb ik errors. 
Ik krijg dat mutations niet defined zijn. 

Ah ik moet string van de mutatienaam gebruiken bij commit. 
Maar ik wil eigenlijk eerst uitzoeken of ik die consts wil gebruiken. Ik zie nog steeds niet waarom dat handig is
Ik heb op verschillende plekken gelezen dat het aan wordt geraden door de styleguides, maar ik kan het niet vinden. Misschien is het niet meer zo. 
Ik denk dat het zo is omdat je geen string in je code wilt. En het is makkelijker als je met meerder programmeurs werkt. Ik denk dat het vooral een goede practice is om strings weg te halen. 

Het is zowieso niet essenieel, maar als het toch al wordt gedaan kan ik het net zo goed gebruiken.
Ja, ik gebuik het gewoon. 
Okee gedaan, nu maar eens in de view gebruiken. 
*** First communication
Ik wil de store functionaliteit gebruiken in mn login component om een login request te sturen naar de backend. En dan verder kijken. 

Ik heb de component dus nu moet ik gewoon inloggen en dan kijken bij flask. 
Maar denk ik dus. Ik werk eigenlijk in twee projecten tegelijkertijd. Hoe ga ik dat kwa workflow doen. 
Ik denk dat ik een workspace wil reserveren voor flask. 
Ja dat ga ik doen. Gedaan. 
Alleen de files synchroniseren niet. 

Er is denk ik een error in mijn login view, want er wordt niks displayed. 
In de console staat dat 'input' not defined is. Maar het werkte eerst wel.
Ah het ging om een var en niet om een html element. 

Ik krijg een error axios niet is defined. Ik herrinner dat ik de init moest executen. 
Nu andere error, response is undefined. 
Ik snap responses en arrow functies niet, dus ik ga dat maar ff begrijpen. 

Oke ik snap eindelijk arrow functies en promises, maar nog steeds is het wel vaag.
Ik was super in de war door de login promise. Ik kom er net achter dat er twee promises zijn axios maakt er ook 1. 

Ik denk dat de promise in de store gewoon is gemaakt zodat het asynchroon kan. 

Nu vraag ik me dus af wat de error betekent. "response is undefined"
Misschien is het gewoon omdat er nooit een response is gekomen, maar ik kreeg de error wel heel snel. 

Okee ik snap m. Ik gaf geen credentials mee waardoor de apiservice een response undefined error gaf. 
Wat ik eigenlijk totaal geen logische error vind. En bij promises definieer je argumenten die verwijzen naar functies die worden uitgevoerd op resolve/failure. Vervolgens definieer je die functies in de then. 

Waarschijnlijk returned het gelijk omdat de server geen connecties toestaat als cors niet gebruikt wordt. 
*** CORS
Okee, ik moet dit iig fixen ik denk dat het het probleem verhelpt. 

Ik zit net een tuto te kijken en het blijkt zo te zijn dat er een cors error komen ipv de error die ik heb. Ik heb geen idee wat de error is die ik dan krijg. Ik ga nu dat voorbeeld namaken en dan wat cors shit sturen. 

Na kutten met flask zie ik dat flaks nooit een bericht heeft ontvangen. Misschien is url verkeerd. 
Zelfs als de url verkeerd was dan zou ik nog een 404 moeten zien. Er zit echt een error in de frontend. 

Ik snap opnieuw niet wat er gebeurd in de login. 
Ik snap nu wel wat er gebeurd. Axios creert een promise en die wordt niet fulfilled waardoor de catch wordt aan geroepen. En daarin is de response niet defined. Ik denk dat het toch cors van server is. 
Het blijkt zo te zijn dat de browser packets blokkeerd als cors niet geactiveerd is in de header.

Ik zit dus te kijken hoe ik cors gebruik in python en ik ontdek nu pipenv. 
Ik eerst over op pipenv. 
*** pipenv
Okee, ik denk maar gewoon de huidige env verwijderen
dan pipenv installeren
dan nieuwe env maken
dan alles opnieuw installeren. 

Oke done.
*** cors wieder
ik heb redelijk zeker het cors probleem opgelost wat ik heb getest via een tets.html file en het werkt maar bij vue niet. Dus wat kan het zijn. 

het probleem is de baseURL. Ik snap niet dat het niet klopt. 
ik moest https:// toevoegen. 

nog steeds een error. Nu de cors error. Maar de cors error komt door een internal error. 
Dus die nu eerst. 

Om het op te lossen moet eigenlijk gewoon iets returnen, maar ik wil eigenlijk gewoon het juiste returnen. Dus ik moet uitzoeken wat de responses kunnen zijn en er dan gewoon 1 van dummy implementeren. 

Ik denk dat ik eigenlijk gewoon echt veel wil gaan programmeren backend nu. 
** User backend                 || example project study
Ik ontdek net de realword flask backend en ga grote delen gewoon overnemen. 
Het hele userdeel en structuur kan ik overnemen. Ik vind realworld echt geniaal eigenlijk. 

Mijn plan atm is om realworld flask backend te begrijpen. 
Ik denk dat ik bluepprints moet begrijpen en ik ga dat maar doen door terug te gaan naar die tuto. 

Ik was aan het denken over circular dependencies en kwam bij een voorbeeld project. 
Het best mooi, ze genereren een voorbeeld flask project met hun code. Dat is misschien wel wat ik wil. 
Ze gebruiken ook allemaal flask en ptyhon standaards dus het is echt heel goed voor me. 
Anyway, ze gerbuiken daar docker(natuurlijk) en ik denk eigenlijk dat ik dat ook moet doen. 
Ik ben laatst pipenv gaan gebruiken, maar waarvoor heb ik dat nodig als ik het ook gewoon in docker kan doen. 
Dat wil ik waarschijnlijk toch ook bij production gaan doen. 

Maar heb ik pipenv nog nodig als ik docker gebruik. Ik denk dat ik alleen pip nodig heb om shit it installeren. 
Het is blijkbaar in sommige gevallen wel handig om een virtualenv te hebben in docker. Want applicties die bij het docker image
zitten, kunnen op python gebaseerd zijn. Sommige images hebben echter geen python package dependancies, en die kan je wel gebruiken. 
Alpine is een van. Ik denk dat ik die ga gebruiken. Ik hoef dan geen pipenv, maar wel pip. 

Ik probeer een voorbeeld project te begrijpen. Ik snap ten eerst niet waarom er supervisord files in zitten. 
Ik snap niet wat ermee wordt gedaan en waarom. Ik zag ook gunicorn configuratie files, ik wou er achter komen wat gunicorn is. 
En nu snap ik het verschil tussen een webserver en een appserver niet. En heb duizend tabs open. 

Ik denk dat er helemaal geen communicatie tussen de web application server is. Ik denk dat webserver gewoon http request handelt. En de ap server gewoon andere requests. BIjvoorbeeld; ik zou met de webserver mn vuex app online gooien, en die vuex app doet reuests baar de app server. 
https://stackoverflow.com/questions/936197/what-is-the-difference-between-application-server-and-web-server

Nee, de webserver kan shit doorsturen naar de app server. Je moet denk ik dus aangeven wat je door wilt sturen. 
Maar het hoeft denk ik niet dat de webserver shit doorstuurt, je kan net als wat ik doe, ook aangeven wat de app server is en daar direct requests naar doen. 
** Docker
Ik wil beslissen of ik docker wil gebruiken, en eigenlijk weet ik al dat ik dat al wil.
Ik wil het iig voor productie gebruiken, dus waarom niet voor development.

Ik snapte niet waarom port 2992 voor development wordt gebruikt, Ik denk dat het iets met wabpack is.

Ik denk dat het enige wat ik verlies als ik docker voor productie ga gebruiken, is de mogelijkheid om een debugger te gebruiken. Maar een debugger wordt denk ik alleen gebruikt om ergens de code te stoppen en dan waardes te inspecteren/ extra code uitvoeren. Het is handi maar niet essentieel.

Ik heb me een beetje vediept in wat spacemacs layers. LSP en dap o.a. lsp is iets wat ik wel echt wil gaan gebruiken en dap ook. Ik weet alleen niet of dat allemaal gewoon samen werkt. 

Ik snap lsp wel, maar dap niet helemaal. Hoe werken breakpoints?
Ik snap het niet helemaal, maar ik kan me voorstellen dat het gewoon kan.
Ik ga gewoon voorlopig zonder dap werken.

Dan wil ik dus alleen de docker en lsp layer toevoegen. En vervolgens het dockercompose file maken.

Ik zit net te kijken naar dap en weet nu beter hoe het werkt. Je kan in een debugger een app starten.
Er zijn dan niet twee processen maar 1. Het debug process. Er is vervolgens een protocol tussen de editor en de debugger.
Dat wordt het debugger adapter protocol genoemd.
https://microsoft.github.io/debug-adapter-protocol/overview
debugpy is een debugger die naast de debugger ook het dap implementeerd.
debugpy kan met de dap layer van emacs communiceren.

In principe zou docker dus geen belemmering moeten zijn. In docker kan gewoon de debugger gestart worden en daar kan mee verbonden worden in emacs op de host. Maar ik wil dat iig niet zelf implementeren.

Ik snap lsp nu ook. Het is vergelijkbaar met dap. Alleen start je de app in de debugger. Bij lsp start je gewoon een aparte server waar request naar gemaakt worden. Echt nice datik dit snap. En wat een chille technologien. Bravo microsoft.

De python layer gebruikt de lsp gewoon en voegt wat toe. 

Okee goed. Ik ga alleen alsnog dap niet gebruiken. Misschien wel wanneer oet debuggen.
Ik ga wel de docker layer gebuiken en het docker compose file maken.
*** docker wieder
Okeem ik moet de docker layer toevoegen en dan de dockerfiles van het cookiecutter project overnemen.

Ik zie nu dat cc-proj zowel dockerfile als compose file geburikt. Ze maken het image met dockerfile en dan gebuiken ze compose voor wat extra shit. Ik denk shit die anders via de commmandline zou doen.
Wow ik leer hier wel wat nieuws van docker. meerdere froms in 1 dockerfile. 

En ik snapte ook niet hoezo er COPY --from=node in staat.  Ik denk dat ze twee images combineren om de frontende en backend bij elkaar te stoppen. Dat wil ik dus zowieso niet doen. 

Goed, ik heb de dockerlayer en weet wat ik moet doen. Nu dus eerst de dockerfile, en dan de compose.

Ik snap niet hoezo er een user wordt gemaakt bij production en niet bij development.

Ik ben wat shit kwijt door een error van emacs.

Anyway, ik heb nu alles uitgezocht, docker geinstalleerd en een dockerfile en compose filegemaakt.
Het werkt niet. Ik moet namelijk nog pipenv gebruiken in docker. 

Ik heb pipenv en het lijkt te werken. Docker runt zonder error. Maar als ik probeer te connecten in de browser werkt het niet. Ik denk dat het misschien door cors komt.

Ik ga denk eerst ff cors fixen en daarna proberen deze error op te lossen. Oh fuck, ik heb al cors.
Nou een basic index page dan.

Okee, ik probeer er achter te komen waarom het niet werkt. Docker zet een netwerk op  waardoor de app niet op localhost met zijn maar 0.0.0.0. Maar als ik het CMD aanpas in de dockerfile, dan krijg ikeen error: /bin/sh: 1: [: missing ]
Ik heb geen idee hoezo.

Anyway, om het te debiggen moet ik weer allemaal dingen over docker gaan begrijpen.
Ik moet een shell openen in de container en dan daar flask runnen. Dan kom ik denk ik wel achter. 
Ik moet eerst opnieuw gaan uitzoeken wat entrypoint command en run is. 

Het kwam door de entrypoint. Ik had entrypoint "/bin/bash/ -c"erin staan. 
Als je het entrypoint veranderd naar "/bin/bash -c" dan gaan de argumenten van cmd naar de entrypoint ipv naar de cmd.
Dat is counterintuitief want het is geloof ik wel het default command.

Anyway, het werkt. wat nu?
Ik dacht eraan om de directory te mounten, maar ik denk dat dat slechte practise is. Want als ik het zou deployen, dan moeten alle file er gewoon op staan. Wat het is, is dat ik niet snap hoezo flask refreshed als ik een verandering maak.
Het lijkt erop dat copy een soort mount doet.
Oh ik mount het ook. Dat was ik ff vergeten. Maar nu mount ik het, en ik copy het.
Ik hoef het alleen te mounten. IK ga de copy weg halen.
Ik lees net dat je tijdens productie ook volumes moet gebruiken. Ik snap niet hoe je dat mee gaat geven aan een engine, maar dat komt later dan wel. https://docs.docker.com/develop/dev-best-practices/

Ik wil denk ik later nog ff kijken naar optimalisaties. Maar voolopig hou ik het dockerfile als het is. Dan ga ik nu aan de login werken. En dan ga ik daarvoor eerst naar voorbeeld projecten kijken.
** Backend
*** Backend                      || settings
Ik ben aan het kijken naar cookiecutter en realword. Bij cookiecutter maken ze een commands module voor testen. Dit is best wel nice eigenlijk en dat wil ik ook. Ik snap alleen nog niet hoe het werkt.
Blijkbaar kan je gewoon via app.cli.add_command een command toevogen. 
Ik ga dat ook doen, maar nu? Ik dnk eerlijk gezegt dat als je lint en test functionaliteit gaat maken, dat het net zo goed gelijk in het begin kan doen.

Okee, ik ga testen en linten gelijk maken, en begin eerst bij testen.
Ik zit net te kijken naar realworld, zij hebben precies dezelfde structuur eigenlijk.
Dan weet ik wel redelijk zeker dat ik het goed doe. 

De setting worden op verschillende manieren gedaan, ik wil dit ff uitzoeken.
De een deelt het op in production dev en testing, de ander import waardes uit een env file.
Ik denk dat ik de eerste wil. 

Ik hoef eigenlijk niet van een env file dingen te laden want flask doet dat zelf al met het dotenv package. Ik neem dus de realword over.

Het irriteerd me nog wel dat er nu twee env definieren de dingen zijn. Ik denk dat ik de .env file gewoon weg haal en pas gebruik als ik het ergens anders nodig voor heb.
Maar ik moet wel een env var instellen voor waar de app is. Waar doe ik dat dan.

Ik snap het denk ik. Je wilt en .env file met daarin sommige configuratie. Waaronder of je in dev of prod draait. Dan heb je nog andere configuratie file voor je app zelf. Daar staat alleen configuratie van je app. In de .env file kan ook shit voor server oid zitten.

Eigenlijk denk ik dat er geen andere dingen zijn die ik moet configureren. Maar dan nog wil ik denk ik een .env file. Secret key en prod/dev kan in de .env file. Gunicorn workers ook.

Ik denk dat ik de .env files voorlopig gewoon skip en env vars in de dockerfile. Ja dat is het beste.
Ik moet alleen nog bedenken hoe ik secret key ga doen. komt later wel.
*** Backend tests                || wsgi
Ik heb het project wat opgeschond en app.py autoapp en commands toegevoegd.
Ik neem van realworld over want die vind ik toch beter dan cookiecutter.
Ik wil nu tests doen. Van het test command zie ik dat het wordt aangeroepen met:
rv = pytest.main([TEST_PATH, '--verbose'])
Ik vindt dat een beetje raar, maar sure.

Ik zat dus te kijken naar hoe er wordt getest bij realword. Ze gebruiken testapp om wsgi application te testen. Ik wou opnieuw uitzoeken wat dat precies is. Het volgende hielp me.

WSGI is just a set a rules to help unify and standardize how Python applications communicate with web servers. It defines both how applications should send responses and how servers should communicate with applications and pass along the environment and other details about the request. Any application that needs to communicate with any web server implements WSGI, because its the de-facto standard and recommended method for Python. WSGI came about to unify the other implementations (CGI, mod_python, FastCGI).

Dus flask is een framework voor een webapplication. nginx en apache zijn webservers, die comminiceren volgens de wsgi regels. Ik denk dat een wsgi server dan gewoon een webserver is die die wsgi compatible is.

Nope ^ klopt niet. Flask is een webapp framework en heeft iets nodig om python code te executeren. Dat is de appliction server. De appliction servr wil alleen niet alle request handlen. image en css kan beter door een echte webserver gedaan worden. Ik snap  het nog steeds niet helemaal goed maar denk ik iets beter en denk dat ik een kloppende source heb gevonden. 
https://serverfault.com/questions/331256/why-do-i-need-nginx-and-something-like-gunicorn
*** Backend tests
Okee, pytest runt functies die met de naam test beginnen automatisch.
En functies in een class met de naam setup worden voor elke test gerunt.
Dit was wel even wat essentieele info.

De flask documentatie is erg handig, maar om een of andere reden heb ik er erg veel moeite mee om te lezen. Ik snap iig yield fixture nu.

Ik moet nu de context beter gaan begrijpen. Ik snap het redelijk, en het testen nu ook.
Ik denk dat cookiecutter betere tests heeft. Ik kan wel wat basic functionliteit schrijven voor de tests, maar niks echt testen natuurlijk. Ik ga dat maar gewoon doen.

Ik moet er later maar op terugkomen als ik wat heb. 
*** Backend, next?               || general, exceptions
Ik weet niet wat ik nu moet doen. Okee, ik wil nog steeds eerst de authenticatie doen.
Maar ik denk dat ik daarvoor een database moet hebben. Ik ga kijken hoe realword het doet.

Ik heb me ingelezen over flask een beetje. vooral blueprints. Het is toch redelijk verwarrend vind ik.
Maar ik denk dat ik het redelijk snap nu. Je scheidt logica er gewoon mee. Iets wat me vooral verwarde us dat je de structuur zelf kan kiezen. Zoals hier wordt beschreven.
https://exploreflask.com/en/latest/blueprints.html
Maar ik snap niet echt wanneer je de functionele structuur beter kan gebruiken.
Ik vind persoonlijk denk ik de devisional structuur gewoon beter denk ik.
Ik gebruik die wel.
Misschien is de functionele structuur handiger voor het managen van resources.
In dat geval moet ik zowieso voor de divisional structuur gaan. Ik scheidt frontend en backend namelijk volledig en de meeste resources zitten bij de frontend denk ik.

Ik denk dat ik kan zeggen dat blueprints er zijn om structuur te maken in de app, en logica te scheiden wat het makkelijker maakt om te onderhouden.

Goed, ik wil iets maken en daar dan gelijk een test voor schrijven. Ik denk dat ik maar gelijk met de authenticatie begin.

Ik heb nog wat naar de structuur gekeken. In elke blueprint worden de nodige serializers gemaakt. Maar er is een extra file in de main folder. Ik denk voor algemene shit. Verder is er nog een file waar alle extensies geinitialiseerd worden.

Ik kan gewoon beginnen met de routes denk ik. Ik maak de db wel wanneer ik m nodig heb. Ookal is dat bijna gelijk waarschijnlijk. 

Ik zit dus gewoon de files van realword door te kijken. Ik wou de exceptions toe voegen, maar nu snap ik die niet helemaal. Wat ze bij realword doen is anders dan ik op andere plekken zie. 
Ze gebruiken ergens twee keer ()(). Ik snap niet wanneer je dat gebruikt.

Okee ik snap het. Als je een functie hebt die een argument neemt en die een functie returned die ook een argument neemt. Dan kan je gewoon twee keer () hebben en de tweede geeft de waarde aan de gereturnde functie. Ik heb het zelf getest.

Ik denk dat ik de exceptions snap.
app.errorhandler(InvalidUsage)(errorhandler)
Deze regel zegt dat als er een invalidusage error is, dan wordt de functie errorhandler aangeroepen. En zo een invalidusage error raise je zelf.
*** Backend, login
Ik heb een tijdje niet geprogrammeerd maar heb net doorgelezen en denk dat ik weer bij ben.
Ik denk dus dat ik gewoon weer de login ga maken. Laat ik eerst kijken hoe realworld het doet. 

Bij realworld is er een folder gemaakt waarin een blueprint zit die alle functionaliteit voor de authenticatie doet. Ik ga dat ook doen en denk dat ik het meeste gewoon over kan nemen. Maar ik ga eerst alles proberen te begrijpen. Dit is veel werk, maar als ik dit snap, dan snap ik bijna alles denk ik. 

Ik heb een video gekeken van cschafer. Zoals hij het doet, zie ik niet waar ik serializers voor nodig heb. Ik ga denk ik maar een video over sqlalchemy kijken.

Wat is vooral niet begrijp is hoe db.relationship werkt. Ik weet niet wat er precies in de db gebeurd en bij welke table het gezet moet worden.

Ik zit nu een db tuto voor beginners te kijken, maar eigenlijk is het te basic. Ik weet ook niet wat ik nou eigenlijk precies zoek.

Ik realiseer me nu trouwens dat ik ook waarschijnlijk de db in docker wil doen.
Dit is echt moeilijk.

Ik ga de db toevoegen maar eerst de readme fixen. 
** Readme
Ik ga een database in een container zetten en een readme schijven waarin voornamelijk wordt geschreven hoe de docker functies gebruikt kunnen worden. Ik denk dat ik dat zelf nodig heb.

Ik zag dat realword een .rst file gebruikt. Ik heb daar nog nooit mee gewerkt, maar ik leer het ook wel gewoon. 

Ik wil toch geen rst file. Het ziet er niet goed uit in mn buffer. Ik moet het compilen om het overzichtelijk te kunnen zien en ik schijf het nu vooral voor mezelf.

Ik heb nu gewoon een md file gemaakt. Ik heb er minder in dan ik dacht dat er in zou moeten. Maar ik ben er tevreden mee. 
** Db container
Ik moet een database in een container hebben.
Ik moet kiezen welke rdbms ik gebruik. En dan een service maken met daarvan het image denk ik.

Ik heb wat gelezen over welke database ik wil gebruiken en ik dacht dat sqllite goed was voor development en dan eventueel postgress/mysql voor production. Ik zie dat realworld sqlite en postgressql relatiefelijk gebruikt.

Ik hoef nog niet na te denken over productie en ga gewoon sqlite voor dev gebruiken.

Ik moet nu gewoon in de compose file een db service maken en de dev een dependancy daarop laten hebben.

Ik realiseer nu dat als ik sqlite gebruik dat het geen zin heeft om een container ervoor te gebruiken.
Ik ga denk ik dus gewoon mysql of postgress gebruiken.

Ik denk dat ik mysql ga gebruiken omdat het geschikt is voor webapps. Ik heb gelezen dat het mogelijk is om te migreren naar een ander dbms. https://www.quora.com/How-hard-is-it-to-change-a-database-vendor-from-MySQL-to-PostgreSQL-after-the-database-is-populated-in-production

Ik heb een video gekeken over hoe ik het op kan zetten. En eigenlijk moet ik dat nu gewoon doen. Ik merk dat ik het werkelijk doen van dingen vaak uitstel en denk dat het komt omdat ik weet dat ik dan weer problemen tegenkom en dan liever een video kijk waar alle problemen altijd op worden gelost.

Ik heb de db service gemaakt. Wat nu. Ik wil het testen ofzo. Ik moet zowieso de data kunnen inspecteren dus ik moet dat ff doen. Ik heb workbench geinstalleerd, maar ik kan niet verbinden.
Ik ga een yt filmpje kijken waar ze wel kunnen verbinden.

Ik dacht dat ik met de container kon verbinden omdat de port exposed wordt in de dockerfile.
Maar blijkbaar staat dat alleen toe dat andere containers ermee kunnen verbinden. Ik moet dus port mappen of publishen. 

Okee ik kan via workbench verbinden nu. Maar nu wil ik eigenlijk met een client verbinden met de db, dan data toevoegen en dan kijken in workbench of het erin staat.

Ik was verward door het kiezen van een database in een filpje. Maar ik denk dat je gewoon verschillende databases kan hebben. IK denk ook dat een schema naar een database refereerd. Nee, wa ik eerst als database zag is gewoon een schema. Een database kan meerdere schemas hebben.

Ik ben verbonden via de commandline met de db. Nu een db maken en table en wat shit erin gooien.
Okee, done that. 
*** environment vars
Ik moet password iig instellen en moet daar een mooie manier op vinden. 
Ik heb besloten dat ik nog helemaal niet over productie wil nadenken dus ik ga he zo laten.
** sqlalchemy
*** Backend, login wieder        || Uitzoeken sqlalchemy
Ik heb nu een database dus ik kan verder. Ik kan online een database designen, maar ik denk dat als ik de code gewoon schrijf, dat ik vanzelf een overzicht kan krijgen. Ik denk dat er wel code voor is omdat automatisch te genereren.

Ik zit dus opnieuw naar de login van realworld te kijken. En ik realiseer me dat ik documentatie wil hebben. Ik vind sphinx een beetje overkill. Ik denk dat je dat alleen moet gebruiken als je documentatie schrijft voor frameworks ofzo.

Het lijkt erop dat alle documentatie methodes docstrings gebruiken. En ik denk dat als ik documentatie in een docstring schrijf, dat ik niet meer een html file voor documentatie ga maken. Dus ik kan gewoon de login maken en alles in docstrings zetten.

Okee, ik was ff weg door civ6. Ik ga dus verder aan de backend. Ik was bezig met het begrijpen van de realworld backend. Maar misschien kan ik beter gewoon proberen om te beginnen en dan pas als ik vastloop daarnaar te kijken. Waarschijnlijk deed ik dat gewoon omdat ik niet wist hoe ik moest beginnen. Eerlijk gezegd weet ik nu ook niet hoe ik moet beginnen.

Ik denk verbinden met de db, dan een table maken en dan maar is proberen om er iets in te zetten. 
Okee, dus ik moet eerst verbinden en er op een of andere manier achter zien te komen of ik verbonden ben.

Ik he wat gelezen over model classes en mixins, het is iig een stuk duidelijker nu. Ik ga denk ik opschrijven hoe ik denk dat de code werkt.
**** realworld db setup
In extensions.py wordt de db var gemaakt. Daarij wordt de crud mixin toegevoegt zodat crud operaties makkelijker zijn. 
In app.py wordt de extensie aan geroepen en geinitialiseerd.
Ik weet niet wat de init functie precies doet. Ik denk dat het db aan de app toevoegt. MIsschien wat met de configuratie.

In de readme staat dat je de databse tables creert met "flask db init". En dat command staat niet in de commands file. Ik denk dat het van de sqlalchemy package komt. 

Ik lees net de flask sqlalchemy documentatie en er is geen code om te connecten met de db. In de app config wordt db url gezet en dan wordt de db var gemaakt en ik denk dat het dan gewoon gebeurd. 

init_app is iets wat je called voor elke extensie, het zorgt ervoor dat callback en configuratie etc goed is. Maar dit doet me nadenken over de structuur van flask. Ik zat heel erg in de knoei met de structuur van mn thesis project en nu zie een soort van hoe dat bij flask ook was en ze daar mee omgaan. Het grappige is dat ik denk dat de app geen db instantie heeft en de db wel een app instantie.

Wat me zo irriteerd is dat alle documentatie beschijft hoe je je app moet maken en niet hoe flask designed is. Webframeworks zijn denk ik altijd en echt best wel ingewikkeld. De init_app van sqlalchemy zet alleen config defaults.

Anyway ik heb hier waarschijnlijk genoeg over nagedacht nu. Ik ga later wel in een ander framework werken om te zien hoe het daar gaat. 

In realworld wordt de db var gemaakt in extensions. En die wordt geimporteerd in app.py. Bij de extensions zit er ook nog een crud mixin. Oke dat is allemaal logisch, maar er is ook nog een database module. Daar is er ook nog een mixin. In de blueprint models importen ze db van database.py. En maken ze de user model met de surrogatepk mixin. Dat doen ze bij bijna alle models, maar niet allemaal, en daarom is het een mixin en niet onderdeel van de model_class. De modelclass is dus geschreven in de extensions omdat het bij het creeren van de db de model_class gelijk toe moet worden gevoegd. Maar dit doet me wel afvragen of de db niet beter in database.py kan worden geinitialiseerd.

Ik denk dat ik wel snap dat ze het zo hebben gedaan. Ze hebben een extensions.py file gemaakt voor overzicht. En als je dat heb, dan moet je wel de db erbij doen. Anders is het heel verwarrend dat de db niet bij de rest van de extensions zit.

Ik zag net dat er nergens de app wordt geimporteerd. De app import alleen andere shit, en views etc importen ook extensies. Ik zit net opniew corey schafers tuto te kijken, dat stukje over circular imports. En zie nu dat de aanpak van realworld dit probleem oplost. Als de db in een aparte module zet dan hoef je niet de app te importeren bij views. Je kan realiseer ik me net denk ik altijd circular imports op deze manier oplossen. Interesting.

Oke, ik denk dat ik dit genoeg snap. 
**** serializing
Ik snap de structuur en db code nu denk ik. Nu wil ik weten hoe de serializers werken. En waarom dit nodig is. Als ik dit snap, dan kan ik beginnen. 

Ik zie nu pas dat de serializers worden geimporteerd in de views ipv de models. Ik kijk nu een video en zie dat marshalling gebruikt wordt voor de consistentie. Dit is wel logisch. 

Ik begrijp nu dat meta niet specefiek is aan flask-marshmallow en dat meta gebruikt wordt voor confiuratie. Ik heb het meeste van de marshmallow docs gelezen. Ik wil nu alleen nu uitzoeken wat flask-marshmallow precies toevoegd.

Het voegt iets met hyperlinks toe, maar ik heb geen idee waarvoor ik dat zou grbuiken. Het voegt flask sqlalchemy integration toe. Maar eerlijk gezegd wil ik dat denk ik ook niet gebruiken. Als ik dat toevoeg wordt het alleen maar meer magie.

Ik wil alleen nog uitzoeken wat nested is. Oke dat is gewoon voor relationships.
Ik ga denk ik geen marshmallow_sqlalchemy gebruiken.
Ik moet denk ik nogw el nadenken over constants.

en nu marshal_with. marshal_with is een wrap functie die door api_spec en restplus wordt geimplementeerd. Aangezien het marshalling doet moet het data omzetten, maar ik vind het zo raar dat dat gewoon automatisch gedaan wordt.

Ah ik begrijp nu waar restplus voor is. Je schrijft een rest api voor anderen om te gebruiken en daar wil je dan ook gelijk documentatie bij hebben. Dit is anders dan de routes die jezelf gebruikt. Ik heb dus iig geen restplus nodig. Maar als ik marshal_with google, dan krijg ik alleen resultaten van restplus. Okee, restplus heeft het toch een beetje uitgelegd. https://flask-restplus.readthedocs.io/en/stable/marshalling.html
Wat er gereturned wordt in de decorated functie wordt gemarshalled. Dat is ook precies wat ik had verwacht. Nu moet ik dus kiezen of ik marshal_with van de een of de ander gebruik. En ik zie dat er tering veel opties zijn. Ik denk dat het vrij weinig uitmaakt. Ik gebruik gewoon apispec wan thet begint met een a en realworld gebruikt het ook.

Ik zie nu ook dat use_kwargs voor request parsing is. Dat is een stuk logischer. 
*** Backend, login wieder        || Uitzoeken sqlalchemy
Okee, nu ga ik echt wat maken. 
Ik moet gewoon kijken welke code ik nodig heb en dat kopieren, dan testen of alles runt, dan kijken of ik kan communiceren met de frontend. Zelfs als ik zoveel begrijp dan nog is het nog zo moeilijk en veel werk.

Ik wil nu uitzoeken wat de uri is van de db. Ik kijk naar een voorbeeld voor wordpress. Daarbij wordt in de compose file env gezet voor de db uri. Ik moet dat ook doen. 
Ik moet in de compose in een env zetten wat de uri is, en dan in de configuratie haal ik die waarde op.

Okee, ik heb de uri en alles runt gewoon zonder errors. Maar ik heb geen idee hoe ik kan verifieren of het werkt. Ik geloof niet dat het werkt. 

Ik heb het idee dat mn hele app niet wordt geload. Ik had nog wat oude code wat in de weg zat.
De app load en de setting code wordt gebruikt iig. Maar ik weet niet of er met de db wordt verbonden en ik weet ook niet hoe ik dit kan checken.

Ik zag dat er bij realworld de optie is om "flask db init" te doen. En er staat niks in de docs erover.
Blijkbaar is er een extensie flask-migrate die dat implementeerd. Het wordt gebruikt om veranderingen in de database doorte geven en dan data te houden. Ik ga waarschijnlijk de hele database opnieuw maken dan maar ik vind migrate wel handig en ga het ook gebruiken.

Ik ga nu eerst kijken wat flask script precies doet en of ik dat wil gebruiken. Okee, het si een voorloper van click soort van. Ik heb het iig niet meer nodig. 
Ik leer net van de shell context. Dit is ook wel echt handig. 

Ik was naar migrate aan het kijken en heb de db init commmand niet. Ik ben nu de user blueprint aan het overzetten omdat ik dacht dat het misschien wel zochtbaar is als ik iets van models heb. Ik heb nu dus alles aan het overzetten en heb nu de extensies nodig die realworld al gebruikte, en ik lees ook hoe ze werken.

Ik heb alles van user toegevoegd, maar ik zie nu dat er ook een profile blueprint is. en die wordt gebruikt in de user views. Er is een on-to-one relationship tussen  user en profile. En ik snap niet waarom.

IK zit dus wat dingen over sqlalchemy te lezen en ik kom bij een punt waarbij er een tabel wordt gemaakt dat geen argumenten neemt, maar er dan toch wel een krijgt en dat gaat goed. IK snap er echt niks van. Er gebeurd heel veel magie. Ik wil nog uitzoeken hoe relationship precies werkt.
https://docs.sqlalchemy.org/en/13/orm/basic_relationships.html
dit is erg handig.
En door die pagina begrijp ik het nu aardig.

userprofile is denk ik een many to many rela met andere userprofiles.
Ik heb het uit de uder view gehaald en dank dat het klopt.
** docker
*** docker debuggen
Nu weet ik alleen nog steeds niet waarom ik geen commands heb. 
Okee, ik zag geen errors maar ik moest nog veel shit installeren.
Nu krijg ik een error dat de db url er niet is. Dat klopt, ik kan alleen de db in docker gebruiken.
Ik ga dus maar docker proberen. Ik krijg geen errors maar dat klopt voor geen meter.

Okee, ik moet docker debuggen. Ik wil bash shell in de container openen zodat ik de files kan inspecteren. Ik denk dat enige chille manier is om exec te gebruiken. Maar dat kan alleen op een running container, nu geen probleem, maar toch raar.
Ik kijk in de container en zie dat alle files er zijn. Zoals hoort. Ik snap dan niet dat mnprint statement niet zochtbaar was. Misschien worden alleen logs geshowed. Ja ik weet vrij zeker dat dat het is. Ik moet toch logging opzetten.

Voorlopig kan ik verder want ik krijg wel bugs als ik een pagina probeer te laden.
Ik bcrypt en andere packages toegveoegt aan de pipenv, maar die zijn niet in mn docker image.
Ik moet dat opnieuw builden denk ik. Ik denk dat als ik de dockerfile verander of dependecies toevoeg, dat ik dan opnieuw moet builden. En daarna kan ik prunen. Alleen ik specificeer de build in en de compose file. 

Okee, ik heb geen bugs meer voorlopig. Heb nog niet alles getest. Ik kon gewoon docker-compose build doen. Heb niet gepurged. Ik heb de commands nu. Maar ik durf niet db init te doen.
*** docker db password debuggen
Okee, ik wil dus de workbench starten en dan checken. Ik ehb in de env vars gezet dat het password password is. Maar ik moet example gebruiken om in te loggen.
Ik denk dat ik handmatig de user facelo moet creeren. 
Ik heb trouwens inmn compos file staan: --default-authentication-plugin=mysql_native_password
Ik weet niet wat dit doet eigenlijk. 
Ik ga denk ik een andere mysql container maken en dan met een andere pw. En dan checken of die het eerste password neemt en dan niet meer aan te passen is.
Ik heb de container verwijderd en een nieuwe gemaakt en het ww is nog steeds example. 
Maar als ik zonder compose een mysql container maak dan kan ik niet via workbench connecten. 
Ik kan toch wel connecten. Ik moet alleen -p ....:.... doen. 

Als ik met compose een db opzet dan is het ww gewoon example, ongeacht de env var.
Als ik zonder compose een db opzet dan is het wachtwoord wat ik in de env var zet.

De vraag is dus gewoon, waarom veranderd het niet bij compose. Ik vraag me af of het door die plugin komt. Ik ga denk ik ergens anders een compose file maken en kijken wat er dan gebeurd. Ik kan gewoon niet begrijpen hoe het ww altijd example is.

Ik heb een nieuwe compose file gemaak in een test folder en eerst het pw 'password' gegeven en daarna veranderd naar example. En het password wordt dan niet veranderd naar example. Ik snap niet waarom niet. Het veranderd alleen als ik het volume verwijder. Opzich niet te raar. Ik moet als ik data heb gewoon flush privileges doen. Maar ik ga toch automatisch data invoeren dus ik kan netzo goed het volume verwijderen. Ik snap alleen niet dat het volume niet zochbaar was in de folder. 
*** db init                      || docker debuggen shit installeren
Okee, met "docker-compose down && docker volume rm facelo_dev_db" kan ik het pw resetten.
Nu kan ik dus met workbench connecten en alles lijkt te werken.
Ik wil nu de db init doen en kijken

**** volumes fixen
Ik zag dat de volumes niet kloppen. Ik gebruik nu namelijk niet de folder die ik ervoor had gebruikt.
Maar eigenlijk maakt het niet uit. Het volume is ergens opgeslagen en heb geen idee waar, maar dat maakt niet uit denk ik. Ik hou het gewoon zo. En ik verwijder de folder dan.

Ik ben zo een idioot. De volumes sectie is voor reusable volumes. Ik vond de opties al zo weinig.
Okee, ik heb nu goed gefixed. 

Okee, dan kan ik nu db init doen. Maar zo makkelijk is het alsnog niet. De db moet runnen, maar ik denk de server niet. Want ik moet het init command runnen. Ik denk dat ik zowel de manage als dev service kan laten dependen op de db. 

**** env fixen
Ik ga eerst ff de env file maken. Dit wordt zo echt een rotzooi. 
wanneer ik ook env vars moet zetten dan moet ik maar meerdere maken.

Ik denk dat ik gewoon docker-compose run manage db init kan runnen. Ik denk dat dat zou moeten werken.
error "couldnt fine flask app."
Ik moest de env file toevoegen aan compose. Nu heb ik:
"Please edit configuration/connection/logging settings in '/app/migrations/alembic.ini' before proceeding."
Dat is blijkbaar normaal. 
sqlalchemy.exc.ArgumentError: Could not parse rfc1738 URL from string 'db_dev:3306'
Ik weet dat dat geen goede url is maar dat hoort bij docker te kunnen werken.
Ik heb het uiteindelijk gevonden in de notworking documentatie. Het verwarrende was dat het voorbeeld van wordpress van docker heeft wat ik had. 

**** packages fixen
nu: ModuleNotFoundError: No module named 'MySQLdb'
Ik moet dus wat shit installeren. 
Ik wil eigenlijk gewoon direct in de pipfile zetten wat ik nodig heb. Ik heb dat gedaan en krijg ee error dat de pipfil.lock out of date is. Nu wil ik eigenlijk weer uitzoeken hoe dat allemaal werkt. 

Ik denk niet dat het mogelijk is om gewoon een package in de pipfile te zetten en niet te installeren. Want dan kan ik de lockfile niet maken en dan kan ik het niet installeren in de container. Ik zou het waarschijnlijk wel in de container kunnen installeren en dan daar de lockfile genereren en dan vervolgens met die pipfile en lockfile opnieuw de container builden. Maar dat is echt een omweg. Ik moet gewoon lokaal installeren en desnoods maar verwijderen. 

Ik dat^ dus gewoon gedaan. En nu zit ik apt packages te installeren. Ik heb iig default-libmysqlclient-dev nodig. Ik heb die geinstalleerd en krijg een error dat er geen gcc is. Ik kijk dus bij https://pypi.org/project/mysqlclient/ en zie dat ik ook build-essential moet installeren. Maar ik zit te denken of ik build essential zal installeren of gewoon gcc en andere shit dat ik nodig heb. Ik denk dat ik voor de laatste optie ga. Bij build essential zit ook g++ compiler. Okee, ik had alleen gcc nodig.

Ik moest nog jwt_extended ofzo toevoegen, maar als ik de het toevoeg en dan opnieuw build, dan gebruikt docker de cache en veranderd er niks. Terwijl dit eerder wel gebeurde. facking raar. Okee, maar nu heb ik zonder cache gebuild em nog steeds krijg ik de install jwt error.
Oh het gaat alleen om optional. 

Ik zie nergens dat het deprectated is maar ik denk het wel want ik kan namelijk jwt_required(optional=true) gebruiken. Ik krijg ook een error op user_loader_callback_loader. Het is renamed blijkbaar. 

**** end point overwriting
Nu: AssertionError: View function mapping is overwriting an existing endpoint function: user.wrapper
Ik vind dit echt lastig. Ik ga eerst ff documentatie lezen en als ik het niet vind, dan ga ik gewoon shit verwijderen tot het werkt. Ik kan altijd toch de db verwijderen.

Okee, Het probleem zit in de route /api/user die gebruik ik twee keer. Dit zou moeten werken. 
Het lijkt erop dat flask het gewoon niet toelaat dat je route twee keer gebruikt. Ik moet het met ifelse. Maar ik vind dat zo'n slechte oplossing. In werkelijkheid maken de namen van de api niet zo veel uit denk ik.

Bij realworld hebben alle urls api in de url. Wil ik dat ook?
Anyway, ik weet dat ik het probleem kan oplossen doot andere namen voor de routes te gebruiken en kan ook ifelse gebruiken om hetzelfde route te gebuiken. Ik ben nu gewoon bezig met hoe mn api zou moeten zijn. 

Toch niet, ik haal de error weg wanneer ik jwt_required uit commenteer. Maar ik wou toch naar flask_login kijken.
**** bad url
Nu: ValueError: invalid literal for int() with base 10: '3306?charset=utf8'.
In settings klopt het niet. Ik zie dat ik daar zelf aan het kutten ben geweest. Ik kan dat ook helemaal niet meer herrineren.  

Okee, ik zit dit uit te stellen. Ik moet een user creeren in de db, en de configuratie in settings aan passen. IK begin wil met het laatste. Dit is wel nog redelijk wat werk. 
Ik zie dit: mysql://<username>:<password>@<host>:<port>/<db_name>
Maar moet mn pw niet encrypted zijn?
dialect+driver://username:password@host:port/database
Ik denk dat de urls ook encrypted worden.

Ik moet beslissen of ik het mysql gedeelte van de url in de env file wil, of in de settings.
Dit is echt lastig voor me. Het maakt ook zo weinig uit. Ik heb het dialect alleen nodig in de url. Als ik het alleen nodig het in de url kan ik het denk ik beter bij elkaar houden.

Nee wacht, ik kan het dialect niet in de url zetten in de env, want ik moet het password en usernamen entussen doen. 

Okee, dan nu automatisch een user in de db creeren. 
Nu werkt het zonder errors. Moet wel twee keer docker up doen anders is er een error omdat de db nog niet bestaat. 
** API
Ik moet een api hebben die handig is. Ik dacht van nature aan de exposion van functies. Bijvoorbeeld register. /user/register leek me logisch. Maar ik zit te lezen en het blijkt dat een POST request op /users dat hoort te doen. 

Ik realiseer ineens iets. Er is altijd data dat word over gebracht en die data kan altijd omschreven worden. Ik kan de create_user method gebruiken, maar daarbij wordt de data van een nieuwe user verstuurd. Daarom kan ik beter een url met user gebruiken omdat het een betere representatie van de data is. create_user als url zou nooit een goeie representatie zijn. Het is een representatie van de method die gecalled wordt.

Ik zit nu te lezen over welke http request gebruikt moet worden in welk geval. Ik denk dat het belangrijk is dat ik dit goed begrijp.

https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/
https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design
https://hackernoon.com/restful-api-design-step-by-step-guide-2f2c9f9fcdbf

Anyway, ik denk dat ik gewoon zelf ga kiezen hoe ik de api maak. Ik doe geen login en logout, maar get en delete token. En er is maar 1 type userprofile. register, delete, update, en show_profile zijn dan gewoon, get, post, put, en delete.
Maar wacht; login moet een post req zijn. En post token is niet logisch.
login en logout ijn gewoon aparte routes omdat ze de enige zijn die een functie callen en niet eenentity representeren. Het representeerd de login gegevens en logout representeerd niks. 

Deze is erg goed en verteld oa over hoe http designed was. 
https://www.youtube.com/watch?v=MiOSzpfP1Ww

Deze is erg goed, maar voor public apis. 
https://www.youtube.com/watch?v=P0a7PwRNLVU

Ik moet er misschien over nadenken wat ik nou precies probeer te bereiken hier. Ik wou weten hoe ik mn api in ga richten. Maar wanneer heb ik een antwoord daarop? Ik denk wanneer ik een plan heb.
*** api plan
login, logout apart

/users (get, post, put, delete) for (get_profile, register, update_user, delete_user)
De rest is voorlopig irrelevant.
*** jwt of flask_login
Ik moet eerst uitzoeken of ik jwt ga gabruiken of flask_login. 

https://www.youtube.com/watch?v=nFPzI_Qg3FU
Hier statefull vs stateless apps uitgelegd. Ik wil stateless want het is scaleble. en heb gelezen dat jwt gebruikt kan worden voor stateless en flask_lgin voor statefull. Ik wil dus jwt.

*** jwt error
Okee, dan moet ik nu uitzoeken waarom jwt die error geeft. 
Er was een breaking change. Ik moest haakjes achter jwt_required zetten. 

Ik gebruik alleen nog de code van realworld en moet wat functionaliteit toevoegen. logout en delete user. Maar ik denk dat ik eerst dit wil testen omdat dit zou moeten werken. Ik kan als het goed is nu de db creeren en dan de routes testen en dan het in de frontend verwerken.

*** db upgrade
Okee, de db creeren. Ik heb dus veel migrate heel vaak gerund en ben bang dat ik meerder migrate files heb. Ik zit te denken of ik dat wil verwijderen. Ik weet eigenlijk vrij zeker dat ik er maar 1 heb. Ik bekijk nu de folder. 
Okee ik moest gewoon en upgrade runnen en alles werkt zonder problemen. Nice.

*** routes testen
Nu de routes testen. Ik kan als het goed is gewoon een user creeren. Hoe ga ik dit doen. Ik kan waarschijnlijk gewoon de frontend gebruiken omdat ik die ook van realword heb genomen, maar ik denk dat ik beter een methode kan vinden om mn routes handmatig te testen. Ik denk dat dat uiteindelijk rewarding zal zijn. Postman is een gratis optie en ik denk een goeie optie. Ik ga gewoon dat gebruiken. Ik heb gekeken naar alternatieven, maar er is veel en heeb geen zin om het uit te zoeken. Het lijkt erop dat postman een goeie is. Ik ga dat gewoon installeren. En daarna ook api tests maken.

Ik heb deze tuto gekeken: https://www.youtube.com/watch?v=FjgYtQK_zLE

*** 500 error
Ik heb met postman de register uder request gemaakt en de server geeft internal server error. Ik heb geen idee hoe ik het moet debuggen. Ik voeg een print toe en safe, de app reload en k krijg de error strace te zien. Waarom krijg ik het dan te zien? Aynway, er is een internal server error in mn serializers. Het klopt dat het niet te serializen is omdat ik niks had gestuurd, maar ik zou wel een andere error willen. Wat voor error zou ik moeten krijgen dan? Ik denk 400 bad request. 
Ik zie dat marshmallow normaal een bad request error zou geven maar door strict is true geven ze internal error error. 

Als ik geen data stuur krijg ik een type error want een 500 error wordt. Ik vind ik een 400 error moet krijgen. Aan de andere kant. Ik ga de routes alleen zelf gebruiken. Misschien wil ik wel een internal error als er iets wordt gestuurd wat gewoon niet klopt. En dan wel een 400 error sturen als de user iets stuurt wat niet klopt. Ja ik denk dat.

Okee, ik wil die serializer uitvogelen=, wat doet die ugly hack er?
Ik heb geen idee wat het doet en heb de neiging om ehet te verwijderen. Ik verwijder het gewoon. 

Nu krijg ik nog steeds een typeerror op missing arguments en dat hoort ook. En ik wil ook een internal servererror krijgen denk ik.

*** secret key error
Okee, ik heb eindelijk een request gemaakt dat door de serializer komt en krijg nu:
dev_1     | RuntimeError: JWT_SECRET_KEY or flask SECRET_KEY must be set when using symmetric algorithm "HS256"
Ik heb geen secret key gezet denk ik.
*** no users table
Het werkte eerst en nu niet meer. Ik krijg nu, no such table: users.
Dit slaat helemaal nergens op. 

Ik krijg de error denk ik alleen als ik de debugger uitschakel. Ah natuurlijk, in de autoapp wordt dan de ander configuratie gekozen. 

*** dev, but no debug
Ik wil in dev zonder debug werken. 
Okee, gelukt. get_env ipv get_debug_flag

*** json ipv html response
Okee, het was al door realworld geimplementeerd, maar ik had het weggelaten omdat ik pas wou gebruiken als ik het nodig had. Nu weet ik iig waarom ik het nodig heb.

** tests
Ik heb requests gemaakt om te testen in postman, maar het werkt niet geweldig. Ik moet data verwijderen. Ik kan dus tests in python maken of in postman. Ik denk gewoon pyhton.
Ja zeker python. Ik zie nu ook de testing flag die ik moet gebruiken. Ik weet nog niet hoe ik dat ga doen. Ik wil natuurlijk compose manager test gebruiken. Maar ik kan niet testing flag in de manager env zetten.

Ik kan een extra service maken, of ik kan de testing env var meegeven op een of andere manier.
In cookiecutter maken ze een command en dat de tests start. Ik denk eigenlijk dat daarmee niet de app zelf wordt gestart. Ik dan dat dat perfect is.

Holy, realworld had dat ook gewoon haha. Okee, ik moet ff kijken hoe het werkt en dan de juiste shit kopieren. 

Ik begin het een beetje te snappen. Alles met test prefix wordt getest, de rest wordt helemaal niet gerund tenzij je het importeerd in je tests naruurlijk.

Ik vind dat python te veel magic heeft. Bij testen wordt op een of andere manier testapp geimporteerd. Ik heb geen idee hoe. 
Blijkbaar wordt conftest.py gebruikt om fixtures ofzo te sharen. https://docs.pytest.org/en/stable/fixture.html
Maar ik vind het slecht aangegeven.
*** database
Okee, ik het voorbeeld gebruiken ze een tempfile wat werkt omdat ze sqlite gebruiken. Ik kan dat denk ik niet doen.

Ik kan waarschijnlijk gewoon een test database maken, en aan het einde gewoon drop all doen. 
*** pytest
Ik was bezig met het lezen pytest om beter te begrijpen hoe dat werkt en ik heb nu een redelijk beeld.
Ik ben heel erg inefficient geweest de laatste maand ofzo. Het voelt echt heel kut. Ik begin het nu weer op te pakken.
Ik weet niet meer goed wat ik aan het doen was.

Ik geloof dat ik via tests een user wou creeren en verwijderen ofzo.
Ik denk dat ik gewoon shit van realword moet kopieren. Ik geloof dat ik dat eerst inet kon omdat ik pytest niet snapte.
*** factories
Ik was bezig met het verder begrijpen van de tests en kwam bij factories.
Ik heb best wel veel over factories gelezen, maar het is een stuk ingewikkelder dan ik had verwacht. Dat is eigenlijk bij alles wat ik doe voor dit project. Alle best practices zijn gebruikt, dus ik gebruik heel veel technieken.

Ik snap nu iig wel waarom ze de factories gebruiken voor het make van de users. Op deze manier kunnen ze gemakkelijk meerdere unieke users maken en het is allemaal erg overzichtelijk.

Ik denk dat ik het redelijk begrijp en moet nu gewoon shit kopieren eigenlijk. 

1 ding dat ik nog wel verwarrend vind is de user fixture.
Er wordt een class gecreerd met een get functie die de user creert via een factory en vervolgens ook die user opslaat in een db. 
Maar zij gebruiken dat alleen voor followen en unfollowen. Voor het registreren gebruiken ze gewoon normalen apicallls, wat ok logisch is.
Ik heb voorlopig helemaal geen factories nodig. 
*** Applying
Okee, shit kopieren. Ik moet de user fixture wat aanpassen. 

Okee gedaan, nu testen. Hoe doe ik dat. 
No module named pytest. Ik weet dat ik dat gewoon moet installeren, maar doordat ik dingen met docker heb gedaan is het wat moeijlijer.

Ik heb laatst gelezen dat je ook gewoon readme's in org kan maken. Dat lijkt me eigenlijk veel chiller.
Zonder docker runnen is een probleem omdat de db ook in docker runt. Als ik alleen de db in docker wil runnen, dan moet ik wat variabelen gaan zetten.

nu heb ik de error:
attributeerror: 'sqlalchemy' object has no attribute 'binary'
ik snap niet waarom want het runde eerst wel. 
Ik heb ook geen idee hoe ik dit moet debuggen. 
Okee, ik probeerde het te gebruiken in een shell en ik kreeg een deprecationwarning.
Het is hernoemd naar LargeBinary

Nu kom ik op: "no modulenamed testapp"
Het wordt niet geupdate en ik denk dat het vervangen is door flask test_client.
Maar ik probeer dus beter te begrijpen wat die twee precies doen. 

webtest heeft een post_json optie, test_client heeft een post optie.
Ze beschrijven het allebij als een wrapped application dus ik denk dat ze gewoon hetzelfde doen, ik ga dus proberen om het met test_client te doen. 
**** Replacing testapp with test_client
Ik denk dat ik beidde echt goed moet begrijpen eerst. En dat is kut want ik vind de documentatie van flask echt heel kut.
Ik heb allebij goed opgezocht en ik ben er van overtuigd dat ik test_app met test_client kan vervangen.

Ik zie nu ook dat de app fixture zelf nergens wordt gebruikt bahalve door testapp dus ik kan ik dan naar test_app veranderen. 

De structuur is wel redelijk anders tussen de flask tuto en realworld. Flask tuto heeft geen db fixture. Waarschijnlijk is dat omdat ze geen sqlalchemy gebruiken. Ik zou denken dat ik geen db fixture nodig heb, ookal gebruik ik sqlalchemy. Ik kan namelijk denk ik gewoon de db importeren. Dat wordt in de app ook gedaan.

Ik zie ook in de db fixture dat er dezelfde code is die ook in app staat.
Maar wat er alleen wel is; in de db fixture wordt er drop all gerund, en dat is balagrijk na tests.
Ik weet nu eigenlijk wel zeker dat ik de db fixture nodig heb.

Ik denk wel dat ik "_db.create_all()" kan verwijderen uit de app fixture. Maar het is waarschijnlijk beter als ik dat pas doe wanneer ik de tests eerst werkend heb.

Ik ga nu alleen testapp vervangen met test_client. Ik heb het gedaan, maar het maakt nog niet uit want ik heb alleen nog maar test_models.
**** factory boy
Ik krijg ook een error: no module named 'factory'
IK denk dat het om factory_boy gaat. In de boy docs staat dat je het importeerd als factory, maar ik heb dat nog nooit gezien. 
**** test database
Ik realworld testen ze met sqlite. Ik wil eigenlijk gewoon met mysql testen. Ik denk dat het niet heel moeilijk hoeft te zijn.

Ik denk dat ik gewoon met een andere database moet testen. 
In de devconfig zet ik de db url met environment variabelen. Ik kan denk ik gewoon de db name naar testing veranderen. Ik ga dat gewoon proberen.

(1044, "Access denied for user 'facelo'@'%' to database 'testing'")
De facelo user heeft toegang tot de facelo database en maar niet tot de testing database.
Makes sense. Wat doe ik eraan?

Ik meerder databases maken, maar dat is niet elegant want ik kan dat niet met environment variabelen doen. Ik kan een extra database container maken met een eigen volume en eigen environment vars.
Ik kan ook gewoon de tests doen in de development database, dan moet ik alleen de naam veranderen denk ik. En als ik dan dingen toevoeg in de browser, dan wordt dat verwijderd. Ik vind dit opzich wel prima.
Dan moet ik alleen de bd hernoemen naar facelo-testing denk ik. Dan ik m niet perongeluk verwijderen wanneer ik een test run. 

Ik heb de db_name veranderd naar facelo_testing. En ik ganu gewoon de tests doen op de database die ik ook voor dev gebruik. Het werkt alleen wat errors voor de config.
***** config errors
Bij realworld testen ze dat de juiste config in is gesteld. Maar ik cind dit nutteloos. Ik wil zowieso niet de flask_emv var veranderen nadat de applicatie is gestart want ik heb gelzen dat het gedrag dan niet consistent is.

Ik zou wel een env file voor zowel dev als production kunnen maken en dan dat loaden wanneer ik test, maar dat lijkt me nu iig niet nodig. Ik weet ook nog niet helemaal hoe ik de confiiguratie wil hebben.

Ik laat het gewoon zo voor nu. 
*** Adding user tests
Ik test nu de config en de models, ik wil nu de authenticatie testen.
Dit houdt dus ook in dat ik er achter kom of ik testApp kan vervanger met test_client.

In realworld posten ze met testapp met port_json een dict in de tests. In de code wordt wanneer data ontvangen wordt alles geserialiseerd. Ik denk dat daarbij json wordt omgezet naar een python class. 

In de tutorial posten ze de data in een dict. Ik weet niet of dit automatsich wordt omgezet naar json. 

Okee, ik probeer maar wat en ik krijg een error dat ik required missing positional arguments heb. Ik stuur die arguments wel. Er is zowieso een probleem met het datatype. Misschien moet het gewoon omzetten in json, maar tock lijkt het me sterk. Hoe debug ik dit. 

Ik weet nog steeds niet goed hoe ik het moet debuggen, maar ik heb het wel gedaan.
Ik heb het request aangepast zodat het niet gelijk een error geeft bij serializen of op de argumenten.
En vervolgens het request geinspecteerd.

Misschien is er een decorator met een breakpoint waardoor je dan het request kan inspecteren. Dit zou denk ik wel handig zijn. Ah fuck, ik lees nu dat als je --pdb gebruikt, dan kom je bij een failure in de debugger. Nou goed dat ik dat nu weet. 

Anyway, ik kam erachter dat ik geen json verstuur maar gewoon url veriabelen. 
ik kon gewoon data naar json veranderen en opgelost. 
*** token error
Ik mis een token en het geeft een error. 
Op een of andere manier heb ik die user al in de db. 
Ik zit nu te kijken en het is logisch. Ik snap niet dat ze dit bij realword niet hadden.
De vorige test gebruikt de client fixture en niet de database fixture. Dus de user blijft in de db.
Ik moet uit gaan zoeken hoe de fictures moeten.

Nu een email error. Nee, een Bad authorization.
Ik ben bang dat ik hiervoor echt goed moet gaan begrijpen hoe jwt werkt. 
Ik zie net dat ze de token veranderen bij get_token en dan niet naar de db comitten. Dit is gewoon raar. 
Het betekent dat er iets mis gaat voordat de code van get_user runt. Het gaat dus mis in de serializing denk ik. 
Het gaat mis in de decorator jwt_required. Er wordt een verkeerd authorization header mee gestuurd. Ik heb jwt_required uit gecomment en nu kan ik het request inspecteren met de pdb.

Ik kan alleen niet begrijpen waarom de header niet correct is. 
Ik heb iig token vervangen door Bearer, nu krijg ik de error. 
TypeError: jwt_identity() takes 1 positional argument but 2 were given

Deze error is niet logisch voor mij, ik kan me niet voorstellen dat het een bug is in jwt_extended zelf dus ik denk dat het iets met de configuratie is. Ik ben er van overtuigd dat ik gewoon documentatie moet lezen nu. 

Okee eindelijk opgelost. Het probleem was dat er een identity loader was gemaakt door realworld die op oude code gebaseerd was waarbij er 1 argument ipv twee werden gegeven. Ik heb het aan gepast en alles werkt. 

Ik Heb nu ook de laatste testen gedebugged en alles werkt nu van de authorization. 
*** pytest pdb command
Ik wil pytest met --pdb runnen, hoe fix ik dat in docker
Idealiter geef ik args mee, ik denk dat dat kan. 
** Frontend
Het was een lange trip naar backend, maar nu kan ik weer naar frontend.
Ik wil een erge basic frontend setup maken die makkelijk verbeterd kan worden door Gaby als ze dat leuk vind. 
Wow ik weet gewoon niet waar ik moet beginnen.
Ik denk dat ik gewoon moet lezen wat ik allemaal in het begin heb gedaan. 
Ik heb het gelezen en ik begin me dingen te herrineren, maar het allemaal vaag.
Ik weet niet meer goed waar ik allemaal mee zat.
Ik ga gewoon proberen om de server te starten en dan het te dockerizen. 

"npm run serve" was het command
Ik ga het gewoon dockerizen.
Ook dat is moeilijk. Ik wil mn compose file beter structureren. 
Ik heb eerlijk gezegd het idee dat ik gewoon opnieuw moet beginnen met de frontend.
Ik denk dat het dan overzichtelijker is voor me. Ik heb ook allemaal deprecated warnings. 

Maar eigenlijk, wat ik heb is gewoon het resultaat van vue ui en dan create project. En dan code van realworld toevoegen.
Bij de backend moest de pipenv file kopieren en dan de packages installeren in de container.
Maar ik denk dat ik bij de frontend alles in een folder in het prject wordt geinstalleerd en dan hoef ik denk ik alleen de contents te mounten.
** Docker
Ik wil dus van de frontend ook een docker service maken. 
Ik zag een voorbeeld met een docker file en was verward door de COPY. Ik hoef helemaal geen copy te doen want ik ga het volume mounten in compose. 

Wat me nu verward. Ik heb de front en backand gescheiden. Hoef ik dan wel de node server te installeren.

https://vuejs.org/v2/cookbook/dockerize-vuejs-app.html
Daar laten ze zien hoe je de dockerfile kunt maken. Ze zeggen dan je apache/nginx beter kunt gebruiken voor productie. Ik zou denken dat bij een single page application, je een veel simpelere server kan gebruiken. Bovendien, moet ik nu straks twee keer een server gaan gebruiken, voor de frontend en de backend. Hij lijkt alsof dat raar is.

Ik zit nu vue shit te lezen, maar ik denk eigenlijk dat ik eerst mn compose file moet splitsen. 
Ik ga het toch niet splitsen maar ik ga wel de frontend service maken.
*** Structuur
Ik begin veel services te krijgen en heb structuur nodig.

Je hebt docker compose profile van docker zelf en iets met een dezelfde naam, maar niet van docker.
Ik moet daar later nog naar kijken.

**** 1
- db_dev
- backend_dev
- frontend_dev
- manage_dev
- db_prod
- backend_prod
- frontend_prod
- manage_prod

Alleen dan met dev/prod eerst/
IK denk dat dit het beste is nu. 
Ook weet niet helemaal of manage echt nodig is. Misschien alleen voor productie.
Ik heb pytest via de manage service gerund, maar ik denk dat ik het beter op een andere manier kan doen.
Maar is een probleem voor later.
**** 2
Alhoewel, miscchien kan ik beter een compose file maken alsvolgt:

- database
- backend
- frontend
- manage

En dan voor de productie een andere compose file maken waarbij dingen overwrite van de eerste compose.
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up

Dit wordt ook in de documentatie beschreven, dus misschien is dit wel het beste idee. 
*** manage
Ik wil dit hebben om makkelijk pytest/lint/migrate te kunnen doen.

Het probleem met de huidige opzet is dat ik pytest vie de code oproep waardoor ik minder opties heb.

- Ik kan een extra test service maken
- Ik kan een service maken die het standaard entrypoint opened in de main folder.
  Dan kan ik doen:
  flask <command>
  pytest tests/

Ik ga wel voor die laatste optie. Dat lijkt me iets chiller. 
*** frontend
Ik wil nu dit maken.
Het was wat gekut. Maar geen grote problemen gehad. Het werkt nu. 
**** Volumes
Dit verward me nog bij docker. 
Je hebt volumes op zichzelf en onder services.

While it is possible to declare volumes on the fly as part of the service declaration, this section allows you to create named volumes that can be reused across multiple services (without relying on volumes_from), and are easily retrieved and inspected using the docker command line or API. See the docker volume subcommand documentation for more information.

Ik ga dus gewoon die in de services gebruiken. 

Daarbij moet ik bind gebruiken. https://devopscook.com/docker-volumes-vs-bind-mounts/
** Frontend                     || env
Alles werkt in docker. Nu dus wat pages maken.
Ik ga natuurlijk de login en register page eerst maken.

Ah ik realiseer me nu hoeveel werk de frontend is omdat ik geen fuck van al die technologien snap.
Ik moet iig de api url fixen. Ik wil het definieren in compose en doorgeven aan de container en daar pas uit een env var halen.

Ik was ff aan het denken over de env vars. Moet ik een env file gaan maken voor frontend, backend en database? Het lijkt me beter eigenlijk. Ik wil niet dat als mn frontend gehackt wordt dat het password van de database zichbaar is. Ik denk dat ik uiteindelijk een env file voor elke service is en voor production/development.

Voor de env vars kan ik 2 dingen doen:
1. Ik kan files maken voor de frontend/backend/database.
   - Voordelen:  Vars die niet nodig zijn in een service zijn er ook niet. Security
   - Nadelen:    Als ik een var verander, dan moet ik het in alle files veranderen.
2. Ik kan 1 file met alle vars maken:
   - Voordelen:  Ik hoef env maar 1 keer te zetten.
   - Nadelen:    Vars zitten in een service waar ze niet gebuikt worden.

Het si gewoon een afweging. overzichtelijkheid en gemak tegen security.
Ik weet niet goed wat ik wil. Ik kies maar overzichtelijkheid. 
** Nuxt
Okee, overstappen naar nuxt.

IK weet niet waar ik moet beginnen. Kan ik gewoon een extra folder maken 
Ik ben bezig met de nuxt setup. er zijn nuxt modules waarvan ik niet weet of ik ze wil en ik weet ook niet of ik ze later nog gemakkelijk toe kan voegen.

Aaaand Ive decided not to use nuxt.
Het is een hele lastige beslissing voor me, en ik denk dat ik nog op terug ga komen. 

Hoe moet ik dit probleem eigenlijk behandelen. Ik ken de technologie niet goed en ik weet niet of ik er baat bij ga hebben.
HOe moet iemand theoretisch gezien deze beslissing maken. Ik denk dat je uiteindelijk de technologie moet gebruiken die het meest efficient is.
Ik moet ook niet een technologie gebruiken omdat ik denk dat ik het later misschien opnieuw nodig heb. IK moet gewoon nu gebruiken wat nu het meest efficient is.
Ik denk dat dit vue is want de benefits van nuxt zijn klein, er is minder documentatie en het is meer complex.
*** Why nuxt
**** ssr
I dontm think this is importend for me.
**** forcing good
Ik denk dat ik dat ook niet nodig heb.
**** easier routing
Is nice, maar niet perse nodig.
**** SEO
Dit is denk ik wel belangrijk.
** Frontend
Okee, wat kan ik doen. Ik heb ee beetje documentatie gelezen en wil wat gaan doen.
Ik ga dan eindelijk de login en register maken I guess.
Eerst register. IK moet beginnen met gewoon een simpele form en daarna kan ik de api testen. 
*** Register form
Ik had zelf wat dingen gemaakt, maar ik denk dat ik beter gewoon zo veel mogelijk over kan nemen van vue realworld.

Ik ben helemaal in frontend technologien aan het verdiepen. Realworld heefd een eigen css, maar ik wil natuurlijk bootstrap gebruiken. Volgens mij is dat uiteindelijk het makkelijkst.
Ik heb ook heel ergin webpack verdiept. Ik vind het allemaal nog steeds verwarrend.

Ik snap nu ook redelijk wat bootstrap allemaal kan. (deels) En ik ben blij dat ik dit uit heb gezocht. Het is wel veel uitzoeken allemaal in 1 keer en ik wordt er een beetje gek van. Ik ga zo eerst uitzoeken hoe ik bootstrap het beste aan mn project toe kan voegen en dan alvast een beetje kutten.
Ik denk dat ik een het design voornamelijk zelf moet doen. 
**** bootstrap toevoegen
Ik heb geen zin meer om verder documentatie te lezen, dusik ga dit maar toevoegen eerst.

Ik heb een yt video gekeken waarbij vue-bootstrap werd gebruikt. vue-bootstrap werd geinstalleerd via vue-cli. En vervolgens past vue gewoon de files aan die veranderd moeten worden. Het was best nice.

Ik ga dit ook gewoon doen. 
**** register form
Ik heb het toegevoehd en moet nu gewoon de register form maken.
Ik heb eeb filmje erover gezien en ik denk ik eerst een overzicht wil hebben van alle mogelijkheden die bootstrap biedt. 

Ik ben nuxt tegen gekomen. En heb besloten om het te gebruiken.
Maar toch niet!

Ik heb redelijk wat bootstrap docs gelezen. Je hebt allemaal shit voor form. En er is een mixin genaamd vuelidate.
Die ga ik gebruiken.
**** Actually do it.
Ik had de bootstrap gelezen, maar er zijn tools voor form validation die ik natuurlijk ook wil gebruiken. Ik ga vuelidate gebruiken. Maar vuelidate is niet hetzelfde als bootstrap. Dus ik moet die nu combineren.

Ik denk dat ik gewoon eerst alles in bootstrap moet maken en dan vuelidation moet toevoegen. 

Ik denk dat ik nodig heb:
- email
- password
- gender
- sexual preference
- age
- terms

Okee, ik heb al die dingen erin verwerkt, moet ik het nog mooi maken?
Ik denk het niet. Ik wil alleen dat de schaal goed is. Ik denk dat het stijlen moet beginnen bij de main pages.

Ik denk dat ik een responsive fluid container wil voor de register en login page
Nee ik moet het gewoon een max width geven.

Ik wil denk ik een fluid container, daarin een normal contiainer en daarin de router-view. 
Nee ik denk een fuid container gewoon donker, dan daarin een routerview.

Voor de register page heb ik een fluid container nodig en een max width
Ik heb max van 400px gegeven, ik moet dat later in een stylesheet zetten. 
dat maakt de html voor de register page voorlopig gedaan. 
*** stylesheet
Ik heb style directly in de html nu, dat is natuurlijk niet zo goed.
Ik een stylesheet maken.
*** results page
gewoon een container met cards denk ik.

Ik wil de naming veranderen, misschien overview. Na dat is nu niet belangrijk.

Ik heb de container gemaakt, maar wat doe ik op breakpoints?
Ik denk dat ik opnieuw yt moet kijken. 

Ik heb er lang niet meer aan gewerkt en weet niet meer wat ik moet doen.
Ik heb de resultspage met een small result erin. 
Het lijkt erop dat ik in de resultpage de data op wil halen, dan dat in resultsmaal page wil zetten en dan dat wil displayen. Makes sense. Maar wat nu. Het lijkt erop dat mn data niet wordt doorgegeven. 
okee opgelist, wat nu. 

Ik denk sample data maken en dat displayen. 

Ik wil het echt renamen. Ik denk overview en resultcard. gedaan. 
Ik heb ook de card correct gemaakt en met een for in het overview laten displayen. Alleen het komt allemaal onder elkaar nu. Ik wil nu de opmaak fixen. Alles staat onder elkaar. 

Ik realiseer me nu dat ik misschien eigenlijk helemaal geen cards wil. Anyway, ik ga het nu gebruiken. Ik moet gewoon wat basics in elkaar zetten.

Ik wil de props in de card gebruiken, maar ik weet niet hoe ik dat doe. 
Voor attributes moet ik v-bind gebruiken. In html elements kan ik {{ }} gebruiken.

Ik heb het in een card group gezet en nu is het beter. Het is niet geweldig want uiteindelijk ga ik geen cards gebruiken. nu wil ik dat er 4 op een rij zijn. Ik kan de max width aanpassen, maar het is uiteindelijk beter om de bootstrap systeem te gebruiken. Anyway, ik ga toch nog tering veel veranderen.
*** styling
Ik wil de achtergrond donker maken.

Ik weet niet hoe styling in vue werkt. Ik herrinner me dat je per file style kan toevoegen maar bij codegrade hadden we alles in een aparte stylesheet gezet uiteindelijk. Ik moet ff wat docs lezen denk ik. 

Okee, je hebt:
assets/gloab.css
scoped styling
<style>

Ik ga gewoon style gebruiken, later kan ik global shit doen. 
**** Styling background
Ik denk zwart achter,
En dan dockergrijs eerste laag.

IK heb een global.css nodig denk ik. 
Ik heb de global css maar ik weet niet hoe de dinge heten en welke attributen ze hebben.

Ik denk dat ik het html body element moet aanpassen.
Ik leer net dat html elementen attributen hebben, maar dat zijn niet alle attribueten die je aan een html element kan geven. Je kan ook css attributen geven aan een html element. 
**** styling background
Ik kan in de global css de background color veranderen. Nice
Nu wil ik de volgende laag donker grijs maken.

Ik kan niet het element b-container gebruiken want wanneer het uiteidelijk gerendered wordt, dan betstaat dat element niet. 

Ik heb zitten kijken hoe ik dit moet doen, en ik ben er redelijk van overtuigd dat ik een class of id moet gebruiken. Ik heb ook gekeken hoe je selectors combineerd, dat was essentieel om het correct te doen. Hieronder is een erg goed filmpje. 
https://www.youtube.com/watch?v=1PnVor36_40

Ik moet nu de juiste div vinden en die donker grijs maken. Ik kan gewoon een div om de router-view zetten. Maar nu ik erover nadenk, misschien kan ik dit beter later doen. Waarschijnlijk is het beter om eerst de structuur te doen, en dan kan de div die ik voor de structuur gebruik donker grijs maken.

Ik ga dat gewoon doen.
*** Register & login
Ik heb van deze al de basics. Ik moet nog inloggen met google en fb etc toevoegen.
*** Result
In de eerste versie komt er niet de fancy shit, dus ik hoef dit dan nog niet te maken.
Anders heb ik alleen de foto en de score. 

Dus deze pagina komt niet in de eerste versie. 

*** vote
Ik denk dat ik het beste deze nu kan doen. Ik moet twee photos displayen, de vraag en wat animanties toevoegen.

Ik wil als animatie dat het ene image over het andere gaat.
Dit is wel een challenge eigenlijk. Je hebt anime.js Maar het kan ook met standaard js denk ik.
Ik zoek eigenlijk code om te kopieren. Maar denk niet dat ik dat ga vinden.

**** No animated view
Okee ik probeer gewoon om eerst het view te maken zonder animatie.
Ik snap het hele grid system niet zo goed. 
Ik wil denk ik altijd fluid.
Ik wil alleen dat er iets veranderd wanneer het scherm te klein wordt, maar ik stel dat uit want ik weet niet hoe.

Ik moet waarschijnlijk uiteindelijk met images van variabele grootte gaan werken. Het aantal colums blijft altijd 6 wel.

Ik weet niet zeker of ik het grid system kan gebruiken want ik moet misschien een canvas hebben om de animatie op te doen.
Ja ik realiseer nu dat het grid systeem helemaal niet handig is.

**** anime
Ik ga proberen om anima toe te voegen aan mn project. Dit wordt waarschijnlijk een challenge op zichzelf.
Er is iig vue-animejs

Nu wil ik dat toevoegen, dat kan mee vue cli of met npm, ik ff uitzoeken hoe dat gaat. 

** Logging
** configuratie
Ik wil een structuur die configuratie testing toelaat.
** instance/config.py
Voor configuratie die niet in git mag. 
** Uitzoeken
*** shellcontext
*** errorhandlers
*** extensions
*** strictslashes
*** compat
*** exception class, classmethod
*** Other extensions
** second version
*** Secret key veranderen

*** Results vullen
Ik wil nu mn results view vullen met components. 
De challenge hier is om er dynamisch alle components te creeren. 
Probleem is alleen, ik heb geen zin om hier sample data te maken, en dan opnieuw in de database. 
Ik doe dit laetr denk ik. Ik kan net zo goed met login pagina beginnen. 

Maar als ik sampledata ik de db ga doen, dan ga ik dat alsnog programmeren, dus misschien maakt het niet zoveel uit. 
*** styleguide
*** seo
kan met nuxt
https://testdriven.io/blog/combine-flask-vue/
*** Darkmode
** problems
*** age
Ik weet niet hoe dit invloed gaat hebben.
Dus stel dat je zelf kan instellen door welke leeftijd je beoordeeld wilt worden.
Moet je dan ook instellen met welke leeftijd je vergeleken wordt. Ik denk het niet.
Moet je met dezelfde leeftijd vergeleken worden?
Moet ik de leeftijd laten zien bij het raten?
Wat als je een oude foto upload?
**** 1
Ik denk dat ik gewoon alleen mensen van dezelfze leeftijd met elkaar vergelijk.
En dat ik ook de beoordeler van dezelfde leeftijd laat zijn.
En ik denk dat de beoordeler moet invullen hoe oud die in de foto was. 
**** 2
Dit is wel een probleem eigenlijk. Het verkleind de stemgroep.
Misschien moet ik age weglaten. 
*** results
Ik ben verward over wat voor resultaten ik precies wil hebben.
Als ik age weglaat is het makkelijk. 

Idealiter wil ik zien hoe goed de foto het doet in verschillende regios
Ik wil ook zien hoe goed de foto het doet bij verschillende leeftijden.

Ik kan een grafiek maken met de score(y) per leeftijd(x)
Ik kan een tabel maken met de score per land. Misschien zelfs een map.
Ik kan een grafiek maken met de score(y) per tijdseenheid(x)
**** Score-leeftijd
De score - de leeftijd van de oordeler
De uitdager is random

***** Hoe
Aangezien ik niet de score per leeftijd in de db wil opslaan, moet ik dit bereken.
Dus in de db moet ik zoeken, alle games met deze test, daarvan de judges met leeftijd x.
En dan van die games berekenen wat de elo is voor de persoon. Maar omdat ik dat voor elke leeftijd moet doen, kan ik waarschijnlijk beter een list maken, ordenen en dan per leeftijd uitrekenen.
***** db
In de db moet per game:
Judge
Judge age at the time?
date
Winning_test
Losing_test

**** Score-locatie
Per land of locatie?
Ik denk eigenlijk locatie

***** Hoe
Aangezien ik niet de score per locatie in de db wil opslaan, moet ik dit bereken.
Dus in de db moet ik zoeken, alle games met deze test, daarvan de judges met leeftijd x.
En dan van die games berekenen wat de elo is voor de persoon. Maar omdat ik dat voor elke leeftijd moet doen, kan ik waarschijnlijk beter een list maken, ordenen en dan per leeftijd uitrekenen.

**** Score-Tijd
Ik denk dat deze data niet zo interressant gaat worden.

Ik wil ook niet de score per tijdseenheid op gaan slaan.
Dus ik bereken het uit de data.

Maar omdat ik bij de berekening niet rekening ga houden met de score op dat moment, wordt de data anders.
Dat is opzich geen probleem.

***** Hoe
Voor een master-test, get all challenges, calculate elo per time.

***** db
challenge:
winner
loser
date

*** Active tests
Er moeten standaard instellingen zijn voor de tests.
Ik denk eigenlijk twee type instellingen. Vast en flexibel.
Vast is alleen de leeftijd. en flexibel is waar je de foto laat testen en door welke leeftijd. 

**** age
Dus bijvoorbeeld, je upload als man een foto en wil dat het door alleen vrouwen gerate wordt.
Dan minimale leeftijd is jouw leeftijd/2+7
Maximale leeftijd is jouw leeftijd*2-7

Of misschien moet ik keer 1.25 en gedeelde door 1.25 doen.
**** Photo-location
Huidige locatie?
Of waar je vandaan komt. 
maar dit is waarschijnlijk niet een test instelling.
**** Test-location

*** De score
Ik wil een score in de database hebben om snel scores te berekenen.
Maar als iemand net een foto upload, dan klopt de score nog niet.
Daardoor geeft het vergelijken met nieuwe foto's een minder accurate score.
Ik zou dus een feature kunnen hebben waarbij je opnieuw de score berekend, maar dan met de huidige score van andere foto's.

*** Elo or?
Ik denk eigenlijk dat het elo systeem misschien niet geweldig is.
Voornamlijk omdat stel je elo is x na 10 tests, en dan heb je een aantal negatieve tests, dan is er gelijk een groot verschil. Ik denk dat het erg variabel is.

Misschien moet ik elo doen, en dan dat de afwijking kleiner wordt met de tijd.
Ik denk dat het opnieuw uitrekenen van de score niet met het elo systeem moet gaan, maar iets anders.
Als ik alle challenges random kies, dan kan ik winpercentage laten zien. 
*** Absolute or relative elo
Ik wil graag relative elo laten zien om lelijke mensen niet te kwetsen, ik denk ook dat dat misschien zelfs essentieel is. Maar hoe ga ik dat dan doen met elo per age/location.

Misschien moet ik gewoon een correctie factor bijhouden.
Misschien moet ik de data gewoon zo maken dat het niet met elkaar vergeleken kan worden. Of misschien moet ik dat gewoon zeggen.
Alleen ik denk dat ik het dan misschien te complex maak. En dan moet ik uit gaan leggen wat de resultaten betekenen. Dat is niet chil voor mensen.
Misschien moet ik de optie maken om een score van 0-100 te laten zien. En die ook standaard instellen.
En dan dat de data ook gewoon correct is.

Nou als ik niet de absolute score laat zien, dan moet ik een correctie bij kunnen houden, dan gebruik ik die ook op de location.

** Descriptions
*** Database
**** Master-test
Img-url 
Created-date
Upload-date
Age-in-foto?
Number of votes

question-tests
person
**** question-test
master-test
elo

active tests
challenges
**** active-test
Zodat je kan specificeren als je ergens specifiek voor wilt testen.

test-location
test-age_range
Date-started
active
limit
number of votes

question-test
**** Challenge
Judge
Judge age at the time?
Judge location at the time?
date
Winning_test
Losing_test
**** Person
email
password
gender
sexual preference
Birth-date
Location of residence

Master-tests
*** Overview
Deze bevat alle master tests. 
*** Master test
Je upload een image en kan hier zien welke tests er op het image zijn gedaan.

Mogelijke data:
- upload date
- total votes
- Best score?
- active tests?
- list of questions
*** question test
Dit wordt waarschijnlijk gewoon een component in de master test
Dit geeft de resultaten voor de test met een specefieke vraag.

Mogelijke data:
- master test
- score
- Score-leeftijd
- Score-locatie
- Score-tijd
- active tests
*** Active test
Als je je foto voor een bepaalde vraag wilt testen, dan kan je een active test maken.
Dit wordt waarschijnlijk een component die zowel in de question test/in de master test/in een overview van active tests.

mogelijke data:
- question-test
- settings voor de test
- progressie
** First version
De eerste versie wordt minder complex dan opvolgende.
Ik wil met 1 vraag beginnen en geen mooie data.
*** Overview
Alle master tests
*** master test/question test active test
Aangezien ik hier geen verschillende vragen heb noch mooie data laat zien is dit overbodig. 
*** database
Er zou in principe minder in de database kunnen, maar het maakt niet heel veel uit.
Ik denk dat ik dezelfde database heb. 

* frontend
Vue.js.
** overview van shit
Ik
** views
*** welkom
*** login
*** sign up
*** vote
*** results
Ik denk dat de enige design overweging is hoeveel images ik horizontaal doe. En ik maar gewoon wat nemen. 4

Ik moet eerst sample data hebben vrees ik. 


*** Upload
** components
*** welkom
*** login
*** sign up
*** vote
*** results
*** navigation
*** Upload
hoe wil ik dit doen?
Ik wli het net zo als photofeeler.
* Android App
** overview
Waar begin ik uberhaupt?
Frontend neem ik aan. 

Ik neem gewoon een template met navigation. 
dan maak ik een pagina waar je twee kan vergelijken. 
gewoon twee images
** Android studio 
*** project folder
Je kan de project folder op verschillende manier bekijken, je kan filteren op bepaalde files. 
Dit is best wel handig. 
Ik denk dat ik m gewoon in android moet houden voorlopig
** Android
*** mobile navigation
dit is een overview van de Fragmenten die er zijn
*** actitivity
Dit is lastig om uit te leggen en daarom heet het denk ik ook activity

Ik denk dat ik het nu zou oschrijven als de code die een scherm schrijft en en de code wat het scherm callt. 
*** Fragment
*** Android test vs test
src/androidTest is for unit tests that involves android instrumentation.
src/test is for pure unit test that do not involve android framework. You can run tests here without running on a real device or on emulator.
*** inflation 
Je inflate views van het xml file via kotlin in memory ofzo. 
Een beetje verwarrend.  
